{
    "clean-up": {
        "description": "returns - never returns", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "clean-up"
        ], 
        "declaration": "(clean-up)", 
        "name": "clean-up"
    }, 
    "partial": {
        "description": "Returns a sinusoid at the indicated pitch; the sound is multiplied by env. The start time and duration are taken from env, which is of course subject to transformations. The sample rate is *sound-srate*. The partial function is faster than osc.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "partial", 
            "pitch", 
            "env"
        ], 
        "declaration": "partial(pitch, env)", 
        "name": "partial"
    }, 
    "get-env": {
        "description": "name - the name of the environment variable, returns - string value of the environment variable, nil if variable does not exist", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-env", 
            "name"
        ], 
        "declaration": "get-env(name)", 
        "name": "get-env"
    }, 
    "shift-time": {
        "description": "Shift sound by shift seconds. If the sound is f(t), then the result is f(t - shift). See Figure 5. This is a special case of snd-xform (see Section \"Signal Operations\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "shift-time", 
            "sound", 
            "shift"
        ], 
        "declaration": "shift-time(sound, shift)", 
        "name": "shift-time"
    }, 
    "gc": {
        "description": "returns - nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "gc"
        ], 
        "declaration": "gc()", 
        "name": "gc"
    }, 
    "score-randomize-start": {
        "description": "Alter the start times of notes by a random amount up to plus or minus amt. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-randomize-start", 
            "score", 
            "amt", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-randomize-start(score, amt, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-randomize-start"
    }, 
    "reson": {
        "description": "Apply a resonating filter to sound with center frequency center (in hertz), which may be a float or a signal. Bandwidth is the filter bandwidth (in hertz), which may also be a signal. Filter coefficients (requiring trig functions) are recomputed at each new sample of either center or bandwidth, and coefficients are not interpolated. The last parameter n specifies the type of normalization as in Csound: A value of 1 specifies a peak amplitude response of 1.0; all frequencies other than hz are attenuated. A value of 2 specifies the overall RMS value of the amplitude response is 1.0; thus filtered white noise would retain the same power. A value of zero specifies no scaling. The resulting sample rate, start time, etc. are taken from sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "reson", 
            "sound", 
            "center", 
            "bandwidth", 
            "n"
        ], 
        "declaration": "reson(sound, center, bandwidth, n)", 
        "name": "reson"
    }, 
    "follow": {
        "description": "An envelope follower intended as a commponent for compressor and limiter functions. The basic goal of this function is to generate a smooth signal that rides on the peaks of the input signal. The usual objective is to produce an amplitude envelope given a low-sample rate (control rate) signal representing local RMS measurements. The first argument is the input signal. The floor is the minimum output value. The risetime is the time (in seconds) it takes for the output to rise (exponentially) from floor to unity (1.0) and the falltime is the time it takes for the output to fall (exponentially) from unity to floor. The algorithm looks ahead for peaks and will begin to increase the output signal according to risetime in anticipation of a peak. The amount of anticipation (in seconds) is given by lookahead. The algorithm is as follows: the output value is allowed to increase according to risetime or decrease according to falltime. If the next input sample is in this range, that sample is simply output as the next output sample. If the next input sample is too large, the algorithm goes back in time as far as necessary to compute an envelope that rises according to risetime to meet the new value. The algorithm will only work backward as far as lookahead. If that is not far enough, then there is a final forward pass computing a rising signal from the earliest output sample. In this case, the output signal will be at least momentarily less than the input signal and will continue to rise exponentially until it intersects the input signal. If the input signal falls faster than indicated by falltime, the output fall rate will be limited by falltime, and the fall in output will stop when the output reaches floor. This algorithm can make two passes througth the buffer on sharply rising inputs, so it is not particularly fast. With short buffers and low sample rates this should not matter. See snd-avg for a function that can help to generate a low-sample-rate input for follow. See snd-chase in Section \"Filters\" for a related filter.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "follow", 
            "sound", 
            "floor", 
            "risetime", 
            "falltime", 
            "lookahead"
        ], 
        "declaration": "follow(sound, floor, risetime, falltime, lookahead)", 
        "name": "follow"
    }, 
    "osc": {
        "description": "Returns a sound which is the table oscillated at pitch for the given duration, starting with the phase (in degrees). Defaults are: duration 1.0 (second), table *table*, phase 0.0. The default value of *table* is a sinusoid. Duration is stretched by *warp* and *sustain*, amplitude is nominally 1, but scaled by *loudness*, the start time is logical time 0, transformed by *warp*, and the sample rate is *sound-srate*. The effect of time-warping is to warp the starting and ending times only; the signal has a constant unwarped frequency. Note 1: table is a list of the form (sound pitch-number periodic), where the first element is a sound, the second is the pitch of the sound (this is not redundant, because the sound may represent any number of periods), and the third element is T if the sound is one period of a periodic signal, or nil if the sound is a sample that should not be looped. The maximum table size is set by max_table_len in sound.h, and is currently set to 1,000,000. Note 2: in the current implementation, it is assumed that the output should be periodic. See snd-down and snd-up for resampling one-shot sounds to a desired sample rate. A future version of osc will handle both cases. Note 3: When osc is called, memory is allocated for the table, and samples are copied from the sound (the first element of the list which is the table parameter) to the memory. Every instance of osc has a private copy of the table, so the total storage can become large in some cases, for example in granular synthesis with many instances of osc. In some cases, it may make sense to use snd-flatten (see Section \"Accessing and Creating Sound\") to cause the sound to be fully realized, after which the osc and its table memory can be reclaimed by garbage collection. The partial function (see below) does not need a private table and does not use much space.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "osc", 
            "pitch", 
            "[", 
            "duration", 
            "table", 
            "phase", 
            "]"
        ], 
        "declaration": "osc(pitch [, duration, table, phase])", 
        "name": "osc"
    }, 
    "stretch-abs": {
        "description": "Evaluates beh with *warp* set to a linear time transformation where each unit of logical time maps to factor units of real time. The effect is to stretch the nominal behavior of beh (under the default global environment) by factor. See Chapter \"Continuous Transformations and Time Warps\" for more information.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "stretch-abs", 
            "factor", 
            "beh"
        ], 
        "declaration": "stretch-abs(factor, beh)", 
        "name": "stretch-abs"
    }, 
    "clarinet-freq": {
        "description": "A variation of clarinet that includes a variable frequency control, freq-env, which specifies frequency deviation in Hz. The duration of the resulting sound is the minimum duration of breath-env and freq-env. These parameters may be of type FLONUM or SOUND. FLONUMs are coerced into SOUNDs with a nominal duration arbitrarily set to 30.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "clarinet-freq", 
            "step", 
            "breath-env", 
            "freq-env"
        ], 
        "declaration": "clarinet-freq(step, breath-env, freq-env)", 
        "name": "clarinet-freq"
    }, 
    "snd-abs": {
        "description": "Computes a new sound where each sample is the absolute value of the corresponding sample in sound. You should probably use s-abs instead. (See Section \"More Behaviors\".)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-abs", 
            "sound"
        ], 
        "declaration": "snd-abs(sound)", 
        "name": "snd-abs"
    }, 
    "mapcar": {
        "description": "fcn - the function or function name, listn - a list for each argument of the function, returns - a list of the values returned", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "mapcar", 
            "fcn", 
            "list1", 
            "list..."
        ], 
        "declaration": "mapcar(fcn, list1, list...)", 
        "name": "mapcar"
    }, 
    "consp": {
        "description": "expr - the expression to check, returns - t if the value is a cons, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "consp", 
            "expr"
        ], 
        "declaration": "consp(expr)", 
        "name": "consp"
    }, 
    "show-lpc-data": {
        "description": "Print values of LPC frames from an LPC iterator object. The object is lpc-iterator, which is typically an instance of lpanal-class or lpc-file-class. Frames are numbered from zero, and only files starting at iniframe (a FIXNUM) and ending before endframe (also a FIXNUM) are printed. By default, only the values for RMS1, RMS2, and ERR are printed, but if optional parameter poles? is non-NIL, then the LPC coefficients are also printed.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "show-lpc-data", 
            "lpc-iterator", 
            "iniframe", 
            "endframe", 
            "[", 
            "poles?", 
            "]"
        ], 
        "declaration": "show-lpc-data(lpc-iterator,iniframe, endframe [, poles?])", 
        "name": "show-lpc-data"
    }, 
    "const": {
        "description": "Creates a constant function at the *control-srate*. Every sample has the given value, and the default duration is 1.0. See also s-rest, which is equivalent to calling const with zero, and note that you can pass scalar constants (numbers) to sim, sum, and mult where they are handled more efficiently than constant functions.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "const", 
            "value", 
            "[", 
            "duration", 
            "]"
        ], 
        "declaration": "const(value [, duration])", 
        "name": "const"
    }, 
    "real-random": {
        "description": "Returns a random FLONUM between from and to. (See also rrandom, which is equivalent to (real-random 0 1)).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "real-random", 
            "from", 
            "to"
        ], 
        "declaration": "real-random(from, to)", 
        "name": "real-random"
    }, 
    "pprint": {
        "description": "expr - the expressions to be printed, stream - the output stream (default is standard output), returns - the expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pprint", 
            "expr", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "pprint(expr [, stream])", 
        "name": "pprint"
    }, 
    "open-binary": {
        "description": "fname - the file name string or symbol, :direction - :input or :output (default is :input), returns - a stream", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "open-binary", 
            "fname", 
            "direction:", 
            "direction"
        ], 
        "declaration": "open-binary(fname, direction: direction)", 
        "name": "open-binary"
    }, 
    "expr-has-attr": {
        "description": "Test whether a score event expression has the given attribute.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "expr-has-attr", 
            "expression", 
            "attribute"
        ], 
        "declaration": "expr-has-attr(expression, attribute)", 
        "name": "expr-has-attr"
    }, 
    "snd-log": {
        "description": "Compute the natural logorithm of each sample of sound. Use s-log instead (see Section \"More Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-log", 
            "sound"
        ], 
        "declaration": "snd-log(sound)", 
        "name": "snd-log"
    }, 
    "score-scale": {
        "description": "For each note in the score and in any indicated range, if there is a keyword parameter matching keyword and the parameter value is a number, multiply the parameter value by amount. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-scale", 
            "score", 
            "keyword", 
            "amount", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-scale(score, keyword, amount, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-scale"
    }, 
    "make-copier": {
        "description": "Generate a period from sub-pattern and repeat it repeat times. If merge is false (the default), each repetition of a period from sub-pattern results in a period by default. If merge is true (non-null), then all repeat repetitions of the period are merged into one result period by default. If the for: keyword is used, the same items are generated, but the items are grouped into periods determined by the for: parameter. If the for: parameter is a pattern, it is evaluated every result period. The repeat and merge values may be patterns that return a repeat count and a boolean value, respectively. If so, these patterns are evaluated initially and after each repeat copies are made (independent of the for: keyword parameter, if any). The repeat value returned by a pattern can also be negative. A negative number indicates how many periods of sub-pattern to skip. After skipping these patterns, new repeat and merge values are generated.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-copier", 
            "sub-pattern", 
            "repeat:", 
            "repeat", 
            "merge:", 
            "merge", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-copier(sub-pattern, repeat: repeat, merge: merge, for: for, name: name, trace: trace)", 
        "name": "make-copier"
    }, 
    "congen": {
        "description": "Implements an analog synthesizer-style contour generator. The input gate normally goes from 0.0 to 1.0 to create an attack and from 1.0 to 0.0 to start a release. During the attack (output is increasing), the output converges half-way to gate in risetime (a FLONUM) seconds. During the decay, the half-time is falltime seconds. The sample rate, start time, logical stop, and terminate time all come from gate. If you want a nice decay, be sure that the gate goes to zero and stays there for awhile before gate terminates, because congen (and all Nyquist sounds) go immediately to zero at termination time. For example, you can use pwl to build a pulse followed by some zero time: (pwl 0 1 duty 1 duty 0 1) Assuming duty is less than 1.0, this will be a pulse of duration duty followed by zero for a total duration of 1.0. (congen (pwl 0 1 duty 1 duty 0 1) 0.01 0.05) will have a duration of 1.0 because that is the termination time of the pwl input. The decaying release of the resulting envelope will be truncated to zero at time 1.0. (Since the decay is theoretically infinite, there is no way to avoid truncation, although you could multiply by another envelope that smoothly truncates to zero in the last millisecond or two to get both an exponential decay and a smooth final transition to zero.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "congen", 
            "gate", 
            "risetime", 
            "falltime"
        ], 
        "declaration": "congen(gate, risetime, falltime)", 
        "name": "congen"
    }, 
    "snd-inverse": {
        "description": "Compute the function inverse of signal, that is, compute g(t) such that signal(g(t)) = t. This function assumes that signal is non-decreasing, it uses linear interpolation, the resulting sample rate is srate, and the result is shifted to have a starting time of start. If signal decreases, the true inverse may be undefined, so we define snd-inverse operationally as follows: for each output time point t, scan ahead in signal until the value of signal exceeds t. Interpolate to find an exact time point x from signal and output x at time t. This function is intended for internal system use in implementing time warps.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-inverse", 
            "signal", 
            "start", 
            "srate"
        ], 
        "declaration": "snd-inverse(signal, start, srate)", 
        "name": "snd-inverse"
    }, 
    "case": {
        "description": "expr - the selection expression, case - pair consisting of:, (value expr...) where: value - is a single expression or a list of expressions (unevaluated), expr - are expressions to execute if the case matches returns - the value of the last expression of the matching case", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "case", 
            "expr", 
            "case..."
        ], 
        "declaration": "(case expr case...)", 
        "name": "case"
    }, 
    "random": {
        "description": "n - the upper bound (integer), returns - a random number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "random", 
            "n"
        ], 
        "declaration": "random(n)", 
        "name": "random"
    }, 
    "*default-sf-format*": {
        "description": "The default sound file format. When you write a file, this will be the default format: AIFF for Mac and most Unix systems, NeXT for NeXT systems, and WAV for Win32.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*default-sf-format*"
        ], 
        "declaration": "*default-sf-format*", 
        "name": "*default-sf-format*"
    }, 
    "string": {
        "description": "str1 - the first string to compare, str2 - the second string to compare, :start1 - first substring starting offset, :end1 - first substring ending offset + 1, :start2 - second substring starting offset, :end2 - second substring ending offset + 1, returns - t if predicate is true, nil otherwise, Note: case is significant with these comparison functions.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string", 
            "str1", 
            "str2", 
            "start1:", 
            "start1", 
            "end1:", 
            "end1", 
            "start2:", 
            "start2", 
            "end2:", 
            "end2"
        ], 
        "declaration": "string(str1, str2, start1: start1, end1: end1, start2: start2, end2: end2)", 
        "name": "string"
    }, 
    "snd-biquad": {
        "description": "A general second order IIR filter, where a0 is assumed to be unity. For a1 and a2, the sign convention is opposite to that of Matlab. All parameters except the input sound are of type FLONUM. You should probably use one of lowpass2, highpass2, bandpass2, notch2, allpass2, eq-lowshelf, eq-highshelf, eq-band, lowpass4, lowpass6, lowpass8, highpass4, highpass6, or highpass8, which are all based on snd-biquad and described in Section \"Filter Behaviors\". For completeness, you will also find biquad and biquad-m described in that section.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-biquad", 
            "sound", 
            "b0", 
            "b1", 
            "b2", 
            "a1", 
            "a2", 
            "z1init", 
            "z2init"
        ], 
        "declaration": "snd-biquad(sound, b0, b1, b2, a1, a2, z1init, z2init)", 
        "name": "snd-biquad"
    }, 
    "resample": {
        "description": "Similar to force-srate, except high-quality interpolation is used to prefilter and reconstruct the signal at the new sample rate. Also, the result is scaled by 0.95 to reduce problems with clipping. (See also sound-warp.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "resample", 
            "sound", 
            "srate"
        ], 
        "declaration": "resample(sound, srate)", 
        "name": "resample"
    }, 
    "stkchorus": {
        "description": "Chorus implemented in STK. The input sound can be single or multi-channel. The FLONUM parameters depth and freq set the modulation depth from 0 to 1 and modulation frequency (in Hz), and mix sets the mixture of input sound and chorused sound, where 0.0 means input sound only (dry) and 1.0 means chorused sound only (wet). The parameter delay is a FIXNUM representing the median desired delay length in samples.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "stkchorus", 
            "sound", 
            "depth", 
            "freq", 
            "mix", 
            "[", 
            "delay", 
            "]"
        ], 
        "declaration": "stkchorus(sound, depth, freq, mix [, delay])", 
        "name": "stkchorus"
    }, 
    "snd-t0": {
        "description": "Returns the time of the first sample of the sound. Note that Nyquist operators such as add always copy the sound and are allowed to shift the copy up to one half sample period in either direction to align the samples of two operands. Safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-t0", 
            "sound"
        ], 
        "declaration": "snd-t0(sound)", 
        "name": "snd-t0"
    }, 
    "rem": {
        "description": "expr - the numbers, returns - the result of the remainder operation", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "rem", 
            "expr..."
        ], 
        "declaration": "rem(expr...)", 
        "name": "rem"
    }, 
    "setup-console": {
        "description": "returns - NIL, Note: Under Windows, Nyquist normally starts up in a medium-sized console window with black text and a white background, with a window title of \"Nyquist.\" This is normally accomplished by calling setup-console in system.lsp. In Nyquist, you can avoid this behavior by setting *setup-console* to NIL in your init.lsp file. If setup-console is not called, Nyquist uses standard input and output as is. This is what you want if you are running Nyquist inside of emacs, for example.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "setup-console"
        ], 
        "declaration": "setup-console()", 
        "name": "setup-console"
    }, 
    "snd-white": {
        "description": "Generate white noise, starting at t0, with sample rate sr, and duration d. You probably want to use noise (see Section \"More Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-white", 
            "t0", 
            "sr", 
            "d"
        ], 
        "declaration": "snd-white(t0, sr, d)", 
        "name": "snd-white"
    }, 
    "code-char": {
        "description": "code - the ascii code (integer), returns - the character with that code or nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "code-char", 
            "code"
        ], 
        "declaration": "code-char(code)", 
        "name": "code-char"
    }, 
    "score-sorted": {
        "description": "Test if score is sorted.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-sorted", 
            "score"
        ], 
        "declaration": "score-sorted(score)", 
        "name": "score-sorted"
    }, 
    "fourth": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "fourth", 
            "expr"
        ], 
        "declaration": "fourth(expr)", 
        "name": "fourth"
    }, 
    "subsetp": {
        "description": "Returns true iff a is a subset of b, that is, each element of a is a member of b.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "subsetp", 
            "a", 
            "b"
        ], 
        "declaration": "subsetp(a, b)", 
        "name": "subsetp"
    }, 
    "recip": {
        "description": "A generalized reciprocal function. If sound is a SOUND, compute 1/x for each sample x. If sound is a number x, just compute 1/x. If sound is a multichannel sound, return a multichannel sound with recip applied to each element. The result has the type, sample rate, starting time, etc. of sound. Note that the reciprocal of 0 is undefined (some implementations return infinity), so use this function with care on sounds. Division of sounds is accomplished by multiplying by the reciprocal. Again, be careful not to divide by zero.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "recip", 
            "sound"
        ], 
        "declaration": "recip(sound)", 
        "name": "recip"
    }, 
    "and": {
        "description": "expr - the expressions to be anded, returns - nil if any expression evaluates to nil, otherwise the value of the last expression (evaluation of expressions stops after the first expression that evaluates to nil)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "and", 
            "expr..."
        ], 
        "declaration": "and(expr...)", 
        "name": "and"
    }, 
    "snd-sref": {
        "description": "Evaluates sound at the global time given by time. Safe for ordinary use, but normally, you should call sref instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sref", 
            "sound", 
            "time"
        ], 
        "declaration": "snd-sref(sound, time)", 
        "name": "snd-sref"
    }, 
    "flatsize": {
        "description": "expr - the expression, returns - the length", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "flatsize", 
            "expr"
        ], 
        "declaration": "flatsize(expr)", 
        "name": "flatsize"
    }, 
    "list": {
        "description": "expr - expressions to be combined into a list, returns - the new list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "list", 
            "expr..."
        ], 
        "declaration": "list(expr...)", 
        "name": "list"
    }, 
    "gensym": {
        "description": "tag - string or number, returns - the new symbol", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "gensym", 
            "[", 
            "tag", 
            "]"
        ], 
        "declaration": "gensym([tag])", 
        "name": "gensym"
    }, 
    "sf-info": {
        "description": "Prints information about a sound file. The parameter filename is a string. The file is assumed to be in *default-sf-dir* (see soundfilename below) unless the filename begins with \".\" or \"/\". The source for this function is in the runtime and provides an example of how to determine sound file parameters.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sf-info", 
            "filename"
        ], 
        "declaration": "sf-info(filename)", 
        "name": "sf-info"
    }, 
    "abs-env": {
        "description": "Compute beh in the default environment. This is useful for computing waveform tables and signals that are \"outside\" of time. For example, (at 10.0 (abs-env (my-beh))) is equivalent to (abs-env (my-beh)) because abs-env forces the default environment. Or in SAL, we would say abs-env(my-beh()) @ 10 is equivalent to abs-env(my-beh()).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "abs-env", 
            "beh"
        ], 
        "declaration": "abs-env(beh)", 
        "name": "abs-env"
    }, 
    "swapchannels": {
        "description": "Swap left and right channels in snd, a stereo sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "swapchannels", 
            "snd"
        ], 
        "declaration": "swapchannels(snd)", 
        "name": "swapchannels"
    }, 
    "lognot": {
        "description": "expr - the number, returns - the bitwise inversion of number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lognot", 
            "expr"
        ], 
        "declaration": "lognot(expr)", 
        "name": "lognot"
    }, 
    "digit-char": {
        "description": "n - the digit weight (integer), returns - the digit character or nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "digit-char", 
            "n"
        ], 
        "declaration": "digit-char(n)", 
        "name": "digit-char"
    }, 
    "s-overwrite": {
        "description": "Evaluates the expression, which should result in a sound or an array of sounds, and replaces samples in the given filename. The global *default-sf-dir* applies. A FLONUM is returned, giving the maximum absolute value of all samples written. The sample rate(s) of expression must match those of the file. The maximum number of samples written per channel is given by maxlen, which allows writing the initial part of a very long or infinite sound. If offset is specified, the new sound is written to the file beginning at an offset from the beginning (in seconds). The file is extended if necessary to accommodate the new insert, but if offset falls outside of the original file, the file is not modified. (If necessary, use s-add-to to extend the file with zeros.) The file must be a recognized sound file with a header (not a raw sound file).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-overwrite", 
            "expression", 
            "maxlen", 
            "filename", 
            "[", 
            "offset", 
            "]"
        ], 
        "declaration": "s-overwrite(expression, maxlen, filename [, offset])", 
        "name": "s-overwrite"
    }, 
    "*autonormflag*": {
        "description": "Enables the automatic normalization feature of the play command. You should use (autonorm-on) and (autonorm-off) rather than setting *autonormflag* directly. See Sections \"Memory Space and Normalization\" and \"Sound File Input and Output\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*autonormflag*"
        ], 
        "declaration": "*autonormflag*", 
        "name": "*autonormflag*"
    }, 
    "string-upcase": {
        "description": "str - the string, :start - the starting offset, :end - the ending offset + 1, returns - a converted copy of the string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string-upcase", 
            "str", 
            "start:", 
            "start", 
            "end:", 
            "end"
        ], 
        "declaration": "string-upcase(str, start: start, end: end)", 
        "name": "string-upcase"
    }, 
    "*clipping-error*": {
        "description": "If the peak absolute amplitude value of a sound saved or played exceeds *clipping-threshold*, an XLISP error is raised. See *clipping-threshold* for more detail.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*clipping-error*"
        ], 
        "declaration": "*clipping-error*", 
        "name": "*clipping-error*"
    }, 
    "go": {
        "description": "sym - the tag (quoted), returns - never returns", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "go", 
            "sym"
        ], 
        "declaration": "go(sym)", 
        "name": "go"
    }, 
    "second": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "second", 
            "expr"
        ], 
        "declaration": "second(expr)", 
        "name": "second"
    }, 
    "address-of": {
        "description": "expr - the node, returns - the address of the node (integer)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "address-of", 
            "expr"
        ], 
        "declaration": "address-of(expr)", 
        "name": "address-of"
    }, 
    "append": {
        "description": "expr - lists whose elements are to be appended, returns - the new list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "append", 
            "expr..."
        ], 
        "declaration": "append(expr...)", 
        "name": "append"
    }, 
    "snd-flatten": {
        "description": "This function is identical to snd-length. You would use this function to force samples to be computed in memory. Normally, this is not a good thing to do, but here is one appropriate use: In the case of sounds intended for wavetables, the unevaluated sound may be larger than the evaluated (and typically short) one. Calling snd-flatten will compute the samples and allow the unit generators to be freed in the next garbage collection. Note: If a sound is computed from many instances of table-lookup oscillators, calling snd-flatten will free the oscillators and their tables. Calling (stats) will print how many total bytes have been allocated to tables.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-flatten", 
            "sound", 
            "maxlen"
        ], 
        "declaration": "snd-flatten(sound, maxlen)", 
        "name": "snd-flatten"
    }, 
    "snd-zero": {
        "description": "Creates a sound that is zero everywhere, starts at t0, and has sample rate srate. The logical stop time is immediate, i.e. also at t0. You probably want to use pwl (see Section \"Piece-wise Approximations\") instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-zero", 
            "t0", 
            "srate"
        ], 
        "declaration": "snd-zero(t0, srate)", 
        "name": "snd-zero"
    }, 
    "make-cycle": {
        "description": "Make a cycle pattern that iterates over items. The default period length is the length of items. (See above for a description of the optional parameters.) If items is a pattern, a period of the pattern becomes the list from which items are generated. The list is replaced every period of the cycle.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-cycle", 
            "items", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-cycle(items, for: for, name: name, trace: trace)", 
        "name": "make-cycle"
    }, 
    "poke": {
        "description": "addrs - the address to poke (integer), value - the value to poke into the address (integer), returns - the value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "poke", 
            "addrs", 
            "value"
        ], 
        "declaration": "poke(addrs, value)", 
        "name": "poke"
    }, 
    "plusp": {
        "description": "expr - the number to test, returns - t if the number is positive, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "plusp", 
            "expr"
        ], 
        "declaration": "plusp(expr)", 
        "name": "plusp"
    }, 
    "*default-sound-srate*": {
        "description": "Default value for *sound-srate*. This value is restored when you execute (top) to pop out of a debugging session. Change it by calling (set-sound-srate value).", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*default-sound-srate*"
        ], 
        "declaration": "*default-sound-srate*", 
        "name": "*default-sound-srate*"
    }, 
    "sum": {
        "description": "Returns the sum of a, b, ..., allowing mixed addition of sounds, multichannel sounds and numbers. Identical to sim. In SAL, use the infix \"+\" operator.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sum", 
            "a", 
            "[", 
            "b", 
            "...", 
            "]"
        ], 
        "declaration": "sum(a [, b, ...])", 
        "name": "sum"
    }, 
    "snd-ifft": {
        "description": "This function performs an IFFT on a sequence of spectral frames obtained from iterator and returns a sound. The start time of the sound is given by time. Typically, this would be computed by calling (local-to-global 0). The sample rate is given by srate. Typically, this would be *sound-srate*, but it might also depend upon the sample rate of the sound from which the spectral frames were derived. To obtain each frame, the function sends the message :next to the iterator object, using XLISP's primitives for objects and message passing. The object should return an array in the same format as obtained from snd-fft, and the object should return NIL when the end of the sound is reached. After each frame is inverse transformed into the time domain, it is added to the resulting sound. Each successive frame is added with a sample offset specified by skip relative to the previous frame. This must be an integer greater than zero. If window is not NIL, it must be a sound. This window signal is multiplied by the inverse transformed frame before the frame is added to the output sound. The length of each frame should be the same power of 2. The length is implied by the array returned by iterator, so it does not appear as a parameter. This length is also the number of samples used from window. Extra samples are ignored, and window is padded with zeros if necessary, so be sure window is the right length. The resulting sound is computed on demand as with other Nyquist sounds, so :next messages are sent to iterator only when new frames are needed. One should be careful not to reuse or modify iterator once it is passed to snd-ifft.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-ifft", 
            "time", 
            "srate", 
            "iterator", 
            "skip", 
            "window"
        ], 
        "declaration": "snd-ifft(time, srate, iterator, skip, window)", 
        "name": "snd-ifft"
    }, 
    "*soundenable*": {
        "description": "Controls whether writes to a sound file will also be played as audio. Set this variable by calling (sound-on) or (sound-off).", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*soundenable*"
        ], 
        "declaration": "*soundenable*", 
        "name": "*soundenable*"
    }, 
    "snd-const": {
        "description": "Returns a sound with constant value, starting at t0 with the given duration, at the sample rate srate. You might want to use pwl (see Section \"Piece-wise Approximations\") instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-const", 
            "value", 
            "t0", 
            "srate", 
            "duration"
        ], 
        "declaration": "snd-const(value, t0, srate,duration)", 
        "name": "snd-const"
    }, 
    "stereoize": {
        "description": "Convert a mono sound, snd, to stereo. Four bands of equalization and some delay are used to create a stereo effect.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "stereoize", 
            "snd"
        ], 
        "declaration": "stereoize(snd)", 
        "name": "stereoize"
    }, 
    "*tracenable*": {
        "description": "Controls whether XLISP prints a backtrace when an error is encountered.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*tracenable*"
        ], 
        "declaration": "*tracenable*", 
        "name": "*tracenable*"
    }, 
    "linear-to-vel": {
        "description": "Returns the conversion of x from lineary amplitude to MIDI velocity using a rule that maps unity gain to 127 and -60 dB (0.001) to MIDI velocity 1. The velocity is proportional to the square root of the linear amplitude. The input x can be a FIXNUM or FLONUM but not a sound. The result is a FLONUM.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "linear-to-vel", 
            "x"
        ], 
        "declaration": "linear-to-vel(x)", 
        "name": "linear-to-vel"
    }, 
    "snd-up": {
        "description": "Increases sample rate by linear interpolation. The sound is the signal to be up-sampled, and srate is the output sample rate. Do not call this function. Nyquist performs sample-rate conversion automatically as needed. If you want to force a conversion, call force-srate (see Section \"Sound Synthesis\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-up", 
            "srate", 
            "sound"
        ], 
        "declaration": "snd-up(srate, sound)", 
        "name": "snd-up"
    }, 
    "hash": {
        "description": "sym - the symbol or string, n - the table size (integer), returns - the hash index (integer)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "hash", 
            "sym", 
            "n"
        ], 
        "declaration": "hash(sym, n)", 
        "name": "hash"
    }, 
    "string-lessp": {
        "description": "str1 - the first string to compare, str2 - the second string to compare, :start1 - first substring starting offset, :end1 - first substring ending offset + 1, :start2 - second substring starting offset, :end2 - second substring ending offset + 1, returns - t if predicate is true, nil otherwise, Note: case is not significant with these comparison functions.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string-lessp", 
            "str1", 
            "str2", 
            "start1:", 
            "start1", 
            "end1:", 
            "end1", 
            "start2:", 
            "start2", 
            "end2:", 
            "end2"
        ], 
        "declaration": "string-lessp(str1, str2, start1: start1, end1: end1, start2: start2, end2: end2)", 
        "name": "string-lessp"
    }, 
    "set-sound-srate": {
        "description": "Sets the default sampling rate for audio signals to rate by setting *default-sound-srate* and reinitializing the environment. Do not call this within any synthesis function (see the sound-srate-abs transformation, Section \"Transformations\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "set-sound-srate", 
            "rate"
        ], 
        "declaration": "set-sound-srate(rate)", 
        "name": "set-sound-srate"
    }, 
    "osc-tri": {
        "description": "Returns a triangle waveshape at the indicated frequency (in Hertz). The sample rate is *sound-srate*. The hz parameter may be a sound as in hzosc (see above).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "osc-tri", 
            "hz"
        ], 
        "declaration": "osc-tri(hz)", 
        "name": "osc-tri"
    }, 
    "objectp": {
        "description": "expr - the expression to check, returns - t if the value is an object, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "objectp", 
            "expr"
        ], 
        "declaration": "objectp(expr)", 
        "name": "objectp"
    }, 
    "db-average": {
        "description": "Compute the average amplitude of input in dB.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "db-average", 
            "input"
        ], 
        "declaration": "db-average(input)", 
        "name": "db-average"
    }, 
    "let": {
        "description": "binding - the variable bindings each of which is either:, 1) a symbol (which is initialized to nil), 2) a list whose car is a symbol and whose cadr is an initialization expression expr - the expressions to be evaluated, returns - the value of the last expression", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "let", 
            "binding...", 
            "expr..."
        ], 
        "declaration": "(let (binding...) expr...)", 
        "name": "let"
    }, 
    "snd-bowed-freq": {
        "description": "A bowed model just like snd-bowed but with an additional parameter for continuous frequency control. You should use bowed-freq instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-bowed-freq", 
            "freq", 
            "bowpress-env", 
            "freq-env", 
            "sr"
        ], 
        "declaration": "snd-bowed-freq(freq, bowpress-env, freq-env, sr)", 
        "name": "snd-bowed-freq"
    }, 
    "score-write-smf": {
        "description": "Write a standard MIDI file to filename with notes in score. In this function, every event in the score with a pitch: attribute, regardless of the \"instrument\" (or function name), generates a MIDI note, using the chan: attribute for the channel (default 0) and the vel: attribute for velocity (default 100). There is no facility (in the current implementation) to issue control changes, but to allow different instruments, MIDI programs may be set in two ways. The simplest is to associate programs with channels using the optional programs parameter, which is simply a list of up to 16 MIDI program numbers. Corresponding program change commands are added to the beginning of the MIDI file. If programs has less than 16 elements, program change commands are only sent on the first n channels. The second way to issue MIDI program changes is to add a program: keyword parameter to a note in the score. Typically, the note will have a pitch: of nil so that no actual MIDI note-on message is generated. If program changes and notes have the same starting times, their relative playback order is undefined, and the note may be cut off by an immediately following program change. Therefore, program changes should occur slightly, e.g. 1 ms, before any notes. Program numbers and channels are numbered starting at zero, matching the internal MIDI representation. This may be one less than displayed on MIDI hardware, sequencers, etc. The as-adagio optional parameter should normally be omitted. If non-nil, the file is written in Adagio format, but if you want to do that, call score-write instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-write-smf", 
            "score", 
            "filename", 
            "[", 
            "programs", 
            "as-adagio", 
            "]"
        ], 
        "declaration": "score-write-smf(score, filename,[programs as-adagio])", 
        "name": "score-write-smf"
    }, 
    "sine": {
        "description": "Returns a sinusoid at the indicated pitch. The sample rate is *sound-srate*. This function is like osc with respect to transformations. The sine function is faster than osc.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sine", 
            "pitch", 
            "[", 
            "duration", 
            "]"
        ], 
        "declaration": "sine(pitch [, duration])", 
        "name": "sine"
    }, 
    "mult": {
        "description": "Returns the product of a, b, ..., allowing mixed multiplication of sounds, multichannel sounds and numbers.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "mult", 
            "a", 
            "[", 
            "b", 
            "...", 
            "]"
        ], 
        "declaration": "mult(a [, b, ...])", 
        "name": "mult"
    }, 
    "snd-delaycv": {
        "description": "Feedback delay with variable feedback. This is just like snd-delay except feedback is a sound. You should use feedback-delay instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-delaycv", 
            "sound", 
            "delay", 
            "feedback"
        ], 
        "declaration": "snd-delaycv(sound, delay,feedback)", 
        "name": "snd-delaycv"
    }, 
    "params-transpose": {
        "description": "Add a transposition amount to a score event parameter. The params parameter is a list of keyword/value pairs (not preceded by a function name). The keyword is the keyword of the value to be altered, and amount is a number to be added to the value. If no matching keyword is present in params, then params is returned. Otherwise, a new parameter list is constructed and returned. The original params is not changed.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "params-transpose", 
            "params", 
            "keyword", 
            "amount"
        ], 
        "declaration": "params-transpose(params, keyword,  amount)", 
        "name": "params-transpose"
    }, 
    "snd-offset": {
        "description": "Add an offset to a sound. The resulting start time, logical stop time, stop time, and sample rate are those of sound. Use sum instead (see Section \"Combination and Time Structure\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-offset", 
            "sound", 
            "offset"
        ], 
        "declaration": "snd-offset(sound, offset)", 
        "name": "snd-offset"
    }, 
    "wg-tibetan-bowl": {
        "description": "These sounds are presets for a Banded Wave Guide Percussion instrument implemented in STK. The parameter step is a FLONUM that controls the resultant pitch, and bowpress-env is a SOUND ranging from zero to one that controls a parameter of the model. In addition, bowpress-env determines the duration of the resulting sound. (Note: The bowpress-env does not seems influence the timbral quality of the resulting sound).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "wg-tibetan-bowl", 
            "step", 
            "bowpress-env"
        ], 
        "declaration": "wg-tibetan-bowl(step, bowpress-env)", 
        "name": "wg-tibetan-bowl"
    }, 
    "string-downcase": {
        "description": "str - the string, :start - the starting offset, :end - the ending offset + 1, returns - a converted copy of the string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string-downcase", 
            "str", 
            "start:", 
            "start", 
            "end:", 
            "end"
        ], 
        "declaration": "string-downcase(str, start: start, end: end)", 
        "name": "string-downcase"
    }, 
    "snd-normalize": {
        "description": "Internally, sounds are stored with a scale factor that applies to all samples of the sound. All operators that take sound arguments take this scale factor into account (although it is not always necessary to perform an actual multiply per sample), so you should never need to call this function. This function multiplies each sample of a sound by its scale factor, returning a sound that represents the same signal, but whose scale factor is 1.0.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-normalize", 
            "sound"
        ], 
        "declaration": "snd-normalize(sound)", 
        "name": "snd-normalize"
    }, 
    "apply": {
        "description": "fun - the function to apply (or function symbol), args - the argument list, returns - the result of applying the function to the arguments", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "apply", 
            "fun", 
            "args"
        ], 
        "declaration": "apply(fun, args)", 
        "name": "apply"
    }, 
    "snd-prod": {
        "description": "Computes the product of sound1 and sound2. The resulting sound has its start time at the maximum of the input start times and a logical stop at the minimum logical stop of the inputs. Do not use this function. Use mult or prod instead (see Section \"Sound Synthesis\"). Sample rate, start time, etc. are taken from sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-prod", 
            "sound1", 
            "sound2"
        ], 
        "declaration": "snd-prod(sound1, sound2)", 
        "name": "snd-prod"
    }, 
    "sf-granulate": {
        "description": "Granular synthesis using a sound file named filename as the source for grains. Grains are extracted from a sound file named by filename by stepping through the file in equal increments. Each grain duration is the sum of grain-dur and a random number from 0 to grain-dev. Grains are then multiplied by a raised cosine smoothing window and resampled at a ratio between 1.0 and pitch-dev. If pitch-dev is greater than one, grains are stretched and the pitch (if any) goes down. If pitch-dev is less than one, grains are shortened and the pitch goes up. Grains are then output with an inter-onset interval between successive grains (which may overlap) determined by the sum of ioi and a random number from 0 to ioi-dev. The duration of the resulting sound is determined by the stretch factor (not by the sound file). The number of grains is the total sound duration (determined by the stretch factor) divided by the mean inter-onset interval, which is ioi + ioi-dev * 0.5. The grains are taken from equally-spaced starting points in filename, and depending on grain size and number, the grains may or may not overlap. The output duration will simply be the sum of the inter-onset intervals and the duration of the last grain. If ioi-dev is non-zero, the output duration will vary, but the expected value of the duration is the stretch factor. To achieve a rich granular synthesis effect, it is often a good idea to sum four or more copies of sf-granulate together. (See the gran-test function in gran.lsp.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sf-granulate", 
            "filename", 
            "grain-dur", 
            "grain-dev", 
            "ioi", 
            "ioi-dev", 
            "pitch-dev", 
            "[", 
            "file-start", 
            "file-end", 
            "]"
        ], 
        "declaration": "sf-granulate(filename, grain-dur, grain-dev, ioi, ioi-dev, pitch-dev,[file-start, file-end])", 
        "name": "sf-granulate"
    }, 
    "allpass2": {
        "description": "A fixed-parameter, second-order allpass filter based on snd-biquad. The frequency is given by hz (a FLONUM) and an optional Q factor is given by q (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "allpass2", 
            "signal", 
            "hz", 
            "[", 
            "q", 
            "]"
        ], 
        "declaration": "allpass2(signal, hz [, q])", 
        "name": "allpass2"
    }, 
    "bigendianp": {
        "description": "returns - T if this a big-endian architecture, storing the high-order byte of an integer at the lowest byte address of the integer; otherwise, NIL. (Footnote 14)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "bigendianp"
        ], 
        "declaration": "bigendianp()", 
        "name": "bigendianp"
    }, 
    "score-adjacent-events": {
        "description": "Call (function A B C), where A, B, and C are consecutive notes in the score. The result replaces B. If the result is nil, B is deleted, and the next call will be (function A C D), etc. The first call is to (function nil A B) and the last is to (function Y Z nil). If there is just one note in the score, (function nil A nil) is called. Function calls are not made if the note is outside of the indicated range. This function allows notes and their parameters to be adjusted according to their immediate context. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-adjacent-events", 
            "score", 
            "function", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-adjacent-events(score, function, from-index: i, to-index: j,  from-time: x, to-time: y)", 
        "name": "score-adjacent-events"
    }, 
    "throw": {
        "description": "sym - the catch tag, expr - the value for the catch to return (defaults to nil), returns - never returns", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "throw", 
            "sym", 
            "[", 
            "expr", 
            "]"
        ], 
        "declaration": "throw(sym [, expr])", 
        "name": "throw"
    }, 
    "cerror": {
        "description": "cmsg - the continue message string, emsg - the error message string, arg - the argument expression (printed after the message), returns - nil when continued from the break loop", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cerror", 
            "cmsg", 
            "emsg", 
            "[", 
            "arg", 
            "]"
        ], 
        "declaration": "cerror(cmsg, emsg [, arg])", 
        "name": "cerror"
    }, 
    "snd-extent": {
        "description": "Returns a list of two numbers: the starting time of sound and the terminate time of sound. Finding the terminate time requires that samples be computed. Like most Nyquist functions, this is non-destructive, so memory will be allocated to preserve the sound samples. If the sound is very long or infinite, this may exhaust all memory, so the maxsamples parameter specifies a limit on how many samples to compute. If this limit is reached, the terminate time will be (incorrectly) based on the sound having maxsamples samples. This function is safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-extent", 
            "sound", 
            "maxsamples"
        ], 
        "declaration": "snd-extent(sound, maxsamples)", 
        "name": "snd-extent"
    }, 
    "snd-stop-time": {
        "description": "Returns the stop time of sound. Sounds can be \"clipped\" or truncated at a particular time. This function returns that time or MAX-STOP-TIME if he programmer has not specified a stop time for the sound. Safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-stop-time", 
            "sound"
        ], 
        "declaration": "snd-stop-time(sound)", 
        "name": "snd-stop-time"
    }, 
    "event-end": {
        "description": "Retrieve the end time of event, its time plus its duration.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-end", 
            "event"
        ], 
        "declaration": "event-end(event)", 
        "name": "event-end"
    }, 
    "sort": {
        "description": "list - the list to sort, test - the comparison function, returns - the sorted list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sort", 
            "list", 
            "test"
        ], 
        "declaration": "sort(list, test)", 
        "name": "sort"
    }, 
    "snd-max": {
        "description": "Compute the maximum absolute value of the amplitude of a sound. The sound is created by evaluating expression (as in snd-save), which is therefore normally quoted by the caller. At most maxlen samples are computed. The result is the maximum of the absolute values of the samples. Notes: It is recommended to use peak (see above) instead. If you want to find the maximum of a sound bound to a local variable and it is acceptable to save the samples in memory, then this is probably the function to call. Otherwise, use peak.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-max", 
            "expression", 
            "maxlen"
        ], 
        "declaration": "snd-max(expression, maxlen)", 
        "name": "snd-max"
    }, 
    "poisson-dist": {
        "description": "Returns a FIXNUM value from the Poisson distribution with a mean of delta (a FIXNUM). The Poisson distribution is often used to generate a sequence of time intervals, resulting in random but often pleasing rhythms.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "poisson-dist", 
            "delta"
        ], 
        "declaration": "poisson-dist(delta)", 
        "name": "poisson-dist"
    }, 
    "score-transpose": {
        "description": "For each note in the score and in any indicated range, if there is a keyword parameter matching keyword and the parameter value is a number, increment the parameter value by amount. For example, to tranpose up by a whole step, write (score-transpose 2 :pitch score). The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-transpose", 
            "score", 
            "keyword", 
            "amount", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-transpose(score, keyword,  amount, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-transpose"
    }, 
    "warp": {
        "description": "Evaluates beh with *warp* modified by fn. The idea is that beh and fn are written in the same time system, and fn warps that time system to local time. The current environment already contains a mapping from local time to global (real) time. The value of *warp* in effect when beh is evaluated is the functional composition of the initial *warp* with fn.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "warp", 
            "fn", 
            "beh"
        ], 
        "declaration": "warp(fn, beh)", 
        "name": "warp"
    }, 
    "write-byte": {
        "description": "byte - the byte to write (integer), stream - the output stream (default is standard output), returns - the byte (integer)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "write-byte", 
            "byte", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "write-byte(byte [, stream])", 
        "name": "write-byte"
    }, 
    "dtmf-tone": {
        "description": "Generate a single DTMF tone. The key parameter is either a digit (a FIXNUM from 0 through 9) or the atom STAR or POUND. The duration of the done is given by len (a FLONUM) and the tone is followed by silence of duration space (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "dtmf-tone", 
            "key", 
            "len", 
            "space"
        ], 
        "declaration": "dtmf-tone(key, len, space)", 
        "name": "dtmf-tone"
    }, 
    "hz-to-step": {
        "description": "Returns a step number for freq (in hz), which can be either a number of a SOUND. The result has the same type as the argument. See also step-to-hz (below).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "hz-to-step", 
            "freq"
        ], 
        "declaration": "hz-to-step(freq)", 
        "name": "hz-to-step"
    }, 
    "delete-if": {
        "description": "test - the test predicate, list - the list, returns - the list with matching elements deleted", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "delete-if", 
            "test", 
            "list"
        ], 
        "declaration": "delete-if(test, list)", 
        "name": "delete-if"
    }, 
    "*autonorm-type*": {
        "description": "Determines how the autonorm feature is implemented. Valid values are 'lookahead (the default) and 'previous. See Sections \"Memory Space and Normalization\" and \"Sound File Input and Output\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*autonorm-type*"
        ], 
        "declaration": "*autonorm-type*", 
        "name": "*autonorm-type*"
    }, 
    "require-from": {
        "description": "Tests whether fnsymbol, an unquoted function name, is defined. If not, filename, a STRING, is loaded. Normally fnsymbol is a function that will be called from within the current file, and filename is the file that defines fnsymbol. The path, if a STRING, is prepended to filename. If path is t (true), then the directory of the current file is used as the path.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "require-from", 
            "fnsymbol", 
            "filename", 
            "[", 
            "path", 
            "]"
        ], 
        "declaration": "require-from(fnsymbol, filename [, path])", 
        "name": "require-from"
    }, 
    "room": {
        "description": "returns - nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "room"
        ], 
        "declaration": "room()", 
        "name": "room"
    }, 
    "quantize": {
        "description": "Quantizes sound as follows: sound is multiplied by steps and rounded to the nearest integer. The result is then divided by steps. For example, if steps is 127, then a signal that ranges from -1 to +1 will be quantized to 255 levels (127 less than zero, 127 greater than zero, and zero itself). This would match the quantization Nyquist performs when writing a signal to an 8-bit audio file. The sound may be multi-channel.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "quantize", 
            "sound", 
            "steps"
        ], 
        "declaration": "quantize(sound, steps)", 
        "name": "quantize"
    }, 
    "car": {
        "description": "expr - the list node, returns - the car of the list node", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "car", 
            "expr"
        ], 
        "declaration": "car(expr)", 
        "name": "car"
    }, 
    "sax-freq": {
        "description": "A variation of sax that includes a variable frequency control, freq-env, which specifies frequency deviation in Hz. The duration of the resulting sound is the minimum duration of breath-env and freq-env. These parameters may be of type FLONUM or SOUND. FLONUMs are coerced into SOUNDs with a nominal duration arbitrarily set to 30.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sax-freq", 
            "step", 
            "breath-env", 
            "freq-env"
        ], 
        "declaration": "sax-freq(step, breath-env, freq-env)", 
        "name": "sax-freq"
    }, 
    "cxxxxr": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cxxxxr", 
            "expr"
        ], 
        "declaration": "cxxxxr(expr)", 
        "name": "cxxxxr"
    }, 
    "make-line": {
        "description": "Make a line pattern that iterates over items. The default period length is the length of items. As with make-cycle, items may be a pattern. (See above for a description of the optional parameters.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-line", 
            "items", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-line(items, for: for, name: name, trace: trace)", 
        "name": "make-line"
    }, 
    "snd-print": {
        "description": "Evaluates expression to yield a sound or an array of sounds, then prints up to maxlen samples to the screen (stdout). This is similar to snd-save, but samples appear in text on the screen instead of in binary in a file. This function is intended for debugging. Safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-print", 
            "expression", 
            "maxlen"
        ], 
        "declaration": "snd-print(expression, maxlen)", 
        "name": "snd-print"
    }, 
    "control": {
        "description": "This function is identical to sound, but by convention is used when sound is a control signal rather than an audio signal.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "control", 
            "sound"
        ], 
        "declaration": "control(sound)", 
        "name": "control"
    }, 
    "pwev": {
        "description": "Creates a piece-wise exponential envelope with breakpoints at (0, l1), (t2, l2), etc., ending with (tn, ln). Otherwise, the behavior is like that of pwe.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwev", 
            "l1", 
            "t2", 
            "l2", 
            "t3", 
            "t3", 
            "...", 
            "tn", 
            "ln"
        ], 
        "declaration": "pwev(l1, t2, l2, t3, t3, ... tn, ln)", 
        "name": "pwev"
    }, 
    "pl-position": {
        "description": "The position function builds upon speaker panning to allow more abstract placement of sounds. Like pl-pan2d, it accepts a (monaural) input sound as well as left-to-right (x) and front-to-back (y) coordinates, which may be FLONUMs or SOUNDs. A fourth parameter config specifies the distance from listeners to the speakers (in meters). Current settings assume this to be constant for all speakers, but this assumption can be changed easily (see comments in the code for more detail). There are several important differences between pl-position and pl-pan2d. First, pl-position uses a Cartesian coordinate system that allows x and y coordinates outside of the range (0, 1). This model assumes a listener position of (0,0). Each speaker has a predefined position as well. The input sound's position, relative to the listener, is given by the vector (x,y).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pl-position", 
            "snd", 
            "x", 
            "y", 
            "config"
        ], 
        "declaration": "pl-position(snd, x, y, config)", 
        "name": "pl-position"
    }, 
    "char-upcase": {
        "description": "chr - the character, returns - the upper case character", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "char-upcase", 
            "chr"
        ], 
        "declaration": "char-upcase(chr)", 
        "name": "char-upcase"
    }, 
    "pwer": {
        "description": "Creates a piece-wise exponential envelope with breakpoints at (0, 1), (t1, l1), (t2, l2), ... (tn, 1), where tj is the sum of i1 through ij. In other words, the breakpoint times are specified in terms of intervals rather than cummulative time. Otherwise, the behavior is like that of pwe. Consider using pwerv instead of this one.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwer", 
            "i1", 
            "l1", 
            "i2", 
            "l2", 
            "...", 
            "in"
        ], 
        "declaration": "pwer(i1, l1, i2, l2, ... in)", 
        "name": "pwer"
    }, 
    "peek-char": {
        "description": "flag - flag for skipping white space (default is nil), stream - the input stream (default is standard input), returns - the character (integer)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "peek-char", 
            "[", 
            "flag", 
            "[", 
            "stream", 
            "]", 
            "]"
        ], 
        "declaration": "peek-char([flag [, stream]])", 
        "name": "peek-char"
    }, 
    "lpc-frame-rms1": {
        "description": "Get the energy of the input signal from a frame.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lpc-frame-rms1", 
            "frame"
        ], 
        "declaration": "lpc-frame-rms1(frame)", 
        "name": "lpc-frame-rms1"
    }, 
    "lpc-frame-rms2": {
        "description": "Get the energy of the residual from a frame.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lpc-frame-rms2", 
            "frame"
        ], 
        "declaration": "lpc-frame-rms2(frame)", 
        "name": "lpc-frame-rms2"
    }, 
    "atone": {
        "description": "No longer defined; use hp instead, or define it by adding (setfn atone hp) to your program.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "atone", 
            "sound", 
            "cutoff"
        ], 
        "declaration": "atone(sound, cutoff)", 
        "name": "atone"
    }, 
    "backquote": {
        "description": "expr - the template, returns - a copy of the template with comma and comma-at, expressions expanded", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "backquote", 
            "expr"
        ], 
        "declaration": "backquote(expr)", 
        "name": "backquote"
    }, 
    "*autonorm-max-samples*": {
        "description": "Specifies how many samples will be computed searching for a peak value when *autonorm-type* is 'lookahead. See Sections \"Memory Space and Normalization\" and \"Sound File Input and Output\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*autonorm-max-samples*"
        ], 
        "declaration": "*autonorm-max-samples*", 
        "name": "*autonorm-max-samples*"
    }, 
    "score-filter-length": {
        "description": "Remove notes that extend beyond the cutoff time. This is similar to score-select, but the here, events are removed when their nominal ending time (start time plus duration) exceeds the cutoff, whereas the to-time: parameter is compared to the note's start time. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-filter-length", 
            "score", 
            "cutoff"
        ], 
        "declaration": "score-filter-length(score, cutoff)", 
        "name": "score-filter-length"
    }, 
    "osc-saw": {
        "description": "Returns a sawtooth waveshape at the indicated frequency (in Hertz). The sample rate is *sound-srate*. The hz parameter may be a sound as in hzosc (see above).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "osc-saw", 
            "hz"
        ], 
        "declaration": "osc-saw(hz)", 
        "name": "osc-saw"
    }, 
    "tan": {
        "description": "expr - the floating point number, returns - the tangent of the number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "tan", 
            "expr"
        ], 
        "declaration": "tan(expr)", 
        "name": "tan"
    }, 
    "snd-overwrite": {
        "description": "Evaluates the expression, which should result in a sound or an array of sounds, and replaces samples in the given filename, writing the first frame at a time of offset seconds. The offset must be less than or equal to the duration of the existing file. The duration of the written samples may be greater than that of the file, in which case the file is extended as necessary. The sample rate(s) of expression and the number of channels must match those of the file. If format is SND-HEAD-RAW, then the file format is given by mode (see snd-save, bits (per channel), swap (1 means to swap bytes and 0 means write them in the native byte order), and the number of channels and sample rate of the sound returned by evaluating expression. If the file is a known audio file format, format should be SND-HEAD-NONE, and the other parameters are ignored. Up to a maximum of maxlen samples will be written per channel. The peak value of the sound is returned. In addition, the symbol *RSLT* is bound to a list containing the duration of the written sound (which may not be the duration of the sound file). Use s-add-to (in Section \"Sound File Input and Output\" or s-overwrite (in Section \"Sound File Input and Output\" instead of this function.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-overwrite", 
            "expression", 
            "maxlen", 
            "filename", 
            "offset", 
            "format", 
            "mode", 
            "bits", 
            "swap"
        ], 
        "declaration": "snd-overwrite(expression, maxlen, filename, offset, format, mode, bits, swap)", 
        "name": "snd-overwrite"
    }, 
    "mapc": {
        "description": "fcn - the function or function name, listn - a list for each argument of the function, returns - the first list of arguments", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "mapc", 
            "fcn", 
            "list1", 
            "list..."
        ], 
        "declaration": "mapc(fcn, list1, list...)", 
        "name": "mapc"
    }, 
    "gcd": {
        "description": "n1 - the first number (integer), n2 - the second number(s) (integer), returns - the greatest common divisor", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "gcd", 
            "n1", 
            "n2..."
        ], 
        "declaration": "gcd(n1, n2...)", 
        "name": "gcd"
    }, 
    "setq": {
        "description": "sym - the symbol being set (quoted), expr - the new value, returns - the new value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "setq", 
            "[", 
            "sym", 
            "expr", 
            "]", 
            "..."
        ], 
        "declaration": "setq([sym, expr]...)", 
        "name": "setq"
    }, 
    "length": {
        "description": "expr - the list, vector or string, returns - the length of the list, vector or string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "length", 
            "expr"
        ], 
        "declaration": "length(expr)", 
        "name": "length"
    }, 
    "mapl": {
        "description": "fcn - the function or function name, listn - a list for each argument of the function, returns - the first list of arguments", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "mapl", 
            "fcn", 
            "list1", 
            "list..."
        ], 
        "declaration": "mapl(fcn, list1, list...)", 
        "name": "mapl"
    }, 
    "beta-dist": {
        "description": "Returns a FLONUM value from the Beta distribution. This distribution outputs values between 0 and 1, with outputs more likely to be close to 0 or 1. The parameter a controls the height (probability) of the right side of the distribution (at 1) and b controls the height of the left side (at 0). The distribution is symetric about 1/2 when a = b.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "beta-dist", 
            "a", 
            "b"
        ], 
        "declaration": "beta-dist(a, b)", 
        "name": "beta-dist"
    }, 
    "vel-to-db": {
        "description": "Returns the conversion of x from MIDI velocity to decibels using a rule that maps MIDI velocity 1 to -60 dB and 127 to 0 dB. The amplitude is proportional to the square of MIDI velocity. The input x can be a FIXNUM or FLONUM but not a sound. The result is a FLONUM.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "vel-to-db", 
            "x"
        ], 
        "declaration": "vel-to-db(x)", 
        "name": "vel-to-db"
    }, 
    "env": {
        "description": "Creates a 4-phase envelope. ti is the duration of phase i, and li is the final level of phase i. t3 is implied by the duration dur, and l4 is 0.0. If dur is not supplied, then 1.0 is assumed. The envelope duration is the product of dur, *stretch*, and *sustain*. If t1 + t2 + 2ms + t4 is greater than the envelope duration, then a two-phase envelope is substituted that has an attack/release time ratio of t1/t4. The sample rate of the returned sound is *control-srate*. (See pwl for a more general piece-wise linear function generator.) The effect of time warping is to warp the starting time and ending time. The intermediate breakpoints are then computed as described above.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "env", 
            "t1", 
            "t2", 
            "t4", 
            "l1", 
            "l2", 
            "l3", 
            "[", 
            "dur", 
            "]"
        ], 
        "declaration": "env(t1, t2, t4, l1, l2, l3, [dur])", 
        "name": "env"
    }, 
    "nband-range": {
        "description": "A graphical equalizer applied to input (a SOUND). The gain controls and number of bands is given by gains, an ARRAY of SOUNDs (in other words, a Nyquist multichannel SOUND). Any sound in the array may be replaced by a FLONUM. The bands are geometrically equally spaced from the lowest frequency lowf to the highest frequency highf (both are FLONUMs).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "nband-range", 
            "input", 
            "gains", 
            "lowf", 
            "highf"
        ], 
        "declaration": "nband-range(input, gains, lowf, highf)", 
        "name": "nband-range"
    }, 
    "gate": {
        "description": "Generate an exponential rise and decay intended for noise gate implementation. The decay starts when the signal drops below threshold and stays there for longer than lookahead (a FLONUM in seconds). (The signal begins to drop when the signal crosses threshold, not after lookahead.) Decay continues until the value reaches floor (a FLONUM), at which point the decay stops and the output value is held constant. Either during the decay or after the floor is reached, if the signal goes above threshold, then the ouptut value will rise to unity (1.0) at the point the signal crosses the threshold. Because of internal lookahead, the signal actually begins to rise before the signal crosses threshold. The rise is a constant-rate exponential and set so that a rise from floor to unity occurs in risetime. Similary, the fall is a constant-rate exponential such that a fall from unity to floor takes falltime.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "gate", 
            "sound", 
            "lookahead", 
            "risetime", 
            "falltime", 
            "floor", 
            "threshold"
        ], 
        "declaration": "gate(sound, lookahead, risetime, falltime, floor, threshold)", 
        "name": "gate"
    }, 
    "get-lambda-expression": {
        "description": "closure - the closure, returns - the original lambda expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-lambda-expression", 
            "closure"
        ], 
        "declaration": "get-lambda-expression(closure)", 
        "name": "get-lambda-expression"
    }, 
    "exp-dec": {
        "description": "This convenient envelope shape is a special case of pwev (see Section \"Piece-wise Approximations\"). The envelope starts at 1 and is constant for hold seconds. It then decays with a half life of halfdec seconds until length. (The total duration is length.) In other words, the amplitude falls by half each halfdec seconds. When stretched, this envelope scales linearly, which means the hold time increases and the half decay time increases.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "exp-dec", 
            "hold", 
            "halfdec", 
            "length"
        ], 
        "declaration": "exp-dec(hold, halfdec, length)", 
        "name": "exp-dec"
    }, 
    "sim": {
        "description": "Returns a sound which is the sum of the given behaviors evaluated with current value of *warp*. If behaviors return multiple channel sounds, the corresponding channels are added. If the number of channels does not match, the result has the maximum. For example, if a two-channel sound [L, R] is added to a four-channel sound [C1, C2, C3, C4], the result is [L + C1, R + C2, C3, C4]. Arguments to sim may also be numbers. If all arguments are numbers, sim is equivalent (although slower than) the + function. If a number is added to a sound, snd-offset is used to add the number to each sample of the sound. The result of adding a number to two or more sounds with different durations is not defined. Use const to coerce a number to a sound of a specified duration. An important limitation of sim is that it cannot handle hundreds of behaviors due to a stack size limitation in XLISP. To compute hundreds of sounds (e.g. notes) at specified times, see timed-seq, below. See also sum below.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sim", 
            "[", 
            "beh1", 
            "beh2", 
            "...", 
            "]"
        ], 
        "declaration": "sim([beh1, beh2, ...])", 
        "name": "sim"
    }, 
    "seqrep": {
        "description": "Iteratively evaluates beh with the atom var set with values from 0 to limit-1, inclusive. These sounds are placed sequentially in time as if by seq. The symbol var is a read-only local variable to beh. Assignments are not restricted or detected, but may cause a run-time error or crash. In LISP, the syntax is (seqrep (var limit) beh).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "seqrep", 
            "var", 
            "limit", 
            "beh"
        ], 
        "declaration": "seqrep(var, limit, beh)", 
        "name": "seqrep"
    }, 
    "score-voice": {
        "description": "For each note in the score and in any indicated range, replace the behavior (function) name using replacement-list, which has the format: ((old1 new1) (old2 new2) ...), where oldi indicates a current behavior name and newi is the replacement. If oldi is *, it matches anything. For example, to replace my-note-1 by trombone and my-note-2 by horn, use score-voice(score, {{my-note-1 trombone} {my-note-2 horn}}). To replace all instruments with piano, use score-voice(score, {{* piano}}). The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-voice", 
            "score", 
            "replacement-list", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-voice(score, replacement-list, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-voice"
    }, 
    "pwl-list": {
        "description": "If you have a list of breakpoints, you can use apply to apply the pwl function to the breakpoints, but if the list is very long (hundreds or thousands of points), you might get a stack overflow because XLISP has a fixed-size argument stack. Instead, call pwl-list, passing one argument, the list of breakpoints.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwl-list", 
            "breakpoints"
        ], 
        "declaration": "pwl-list(breakpoints)", 
        "name": "pwl-list"
    }, 
    "gamma-dist": {
        "description": "Return a FLONUM value from a Gamma distribution. The value is greater than zero, has a mean of nu (a FIXNUM greater than zero), and a mode (peak) of around nu - 1. The optional high parameter puts an artificial upper bound on the return value.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "gamma-dist", 
            "nu", 
            "[", 
            "high", 
            "]"
        ], 
        "declaration": "gamma-dist(nu [, high])", 
        "name": "gamma-dist"
    }, 
    "atan": {
        "description": "expr - the value of x, expr2 - the value of y (default value is 1.0), returns - the arctangent of x/y", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "atan", 
            "expr", 
            "[", 
            "expr2", 
            "]"
        ], 
        "declaration": "atan(expr [, expr2])", 
        "name": "atan"
    }, 
    "s-abs": {
        "description": "A generalized absolute value function. If sound is a SOUND, compute the absolute value of each sample. If sound is a number, just compute the absolute value. If sound is a multichannel sound, return a multichannel sound with s-abs applied to each element. The result has the type, sample rate, starting time, etc. of sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-abs", 
            "sound"
        ], 
        "declaration": "s-abs(sound)", 
        "name": "s-abs"
    }, 
    "timed-seq": {
        "description": "Computes sounds from a note list or \"score.\" The score is of the form: `((time1 stretch1 beh1) (time2 stretch2 beh2) ...), where timeN is the starting time, stretchN is the stretch factor, and behN is the behavior. Note that score is normally a quoted list! The times must be in increasing order, and each behN is evaluated using lisp's eval, so the behN behaviors cannot refer to local parameters or local variables. The advantage of this form over seq is that the behaviors are evaluated one-at-a-time which can take much less stack space and overall memory. One special \"behavior\" expression is interpreted directly by timed-seq: (SCORE-BEGIN-END) is ignored, not evaluated as a function. Normally, this special behavior is placed at time 0 and has two parameters: the score start time and the score end time. These are used in Xmusic functions. If the behavior has a :pitch keyword parameter which is a list, the list represents a chord, and the expression is replaced by a set of behaviors, one for each note in the chord. It follows that if :pitch is nil, the behavior represents a rest and is ignored.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "timed-seq", 
            "score"
        ], 
        "declaration": "timed-seq(score)", 
        "name": "timed-seq"
    }, 
    "sound-warp": {
        "description": "Applies a warp function warp-fn to signal using function composition. If the optional parameter wrate is omitted or NIL, linear interpolation is used. Otherwise, high-quality sample interpolation is used, and the result is scaled by 0.95 to reduce problems with clipping (interpolated samples can exceed the peak values of the input samples.) warp-fn is a mapping from score (logical) time to real time, and signal is a function from score time to real values. The result is a function from real time to real values at a sample rate of *sound-srate*. See also control-warp.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sound-warp", 
            "warp-fn", 
            "signal", 
            "[", 
            "wrate", 
            "]"
        ], 
        "declaration": "sound-warp(warp-fn, signal [, wrate])", 
        "name": "sound-warp"
    }, 
    "get-user": {
        "description": "returns - the string naming the user", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-user"
        ], 
        "declaration": "get-user()", 
        "name": "get-user"
    }, 
    "score-get-end": {
        "description": "Return the end time of the score.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-get-end", 
            "score"
        ], 
        "declaration": "score-get-end(score)", 
        "name": "score-get-end"
    }, 
    "alloc": {
        "description": "num - the number of nodes to allocate, returns - the old number of nodes to allocate", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "alloc", 
            "num"
        ], 
        "declaration": "alloc(num)", 
        "name": "alloc"
    }, 
    "third": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "third", 
            "expr"
        ], 
        "declaration": "third(expr)", 
        "name": "third"
    }, 
    "logxor": {
        "description": "expr - the numbers, returns - the result of the exclusive or operation", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "logxor", 
            "expr..."
        ], 
        "declaration": "logxor(expr...)", 
        "name": "logxor"
    }, 
    "cue-file": {
        "description": "Same as cue, except the sound comes from the named file, samples from which are coerced to the current default *sound-srate* sample rate.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cue-file", 
            "filename"
        ], 
        "declaration": "cue-file(filename)", 
        "name": "cue-file"
    }, 
    "read-byte": {
        "description": "stream - the input stream (default is standard input), returns - the byte (integer)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "read-byte", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "read-byte([stream])", 
        "name": "read-byte"
    }, 
    "eq-band": {
        "description": "A fixed- or variable-parameter, second-order midrange equalization (EQ) filter based on snd-biquad, snd-eqbandcv and snd-eqbandvvv. The hz parameter (a FLONUM) is the center frequency, gain (a FLONUM) is the boost (or cut) in dB, and width (a FLONUM) is the half-gain width in octaves. Alternatively, hz, gain, and width may be SOUNDs, but they must all have the same sample rate, e.g. they should all run at the control rate or at the sample rate.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "eq-band", 
            "signal", 
            "hz", 
            "gain", 
            "width"
        ], 
        "declaration": "eq-band(signal, hz, gain, width)", 
        "name": "eq-band"
    }, 
    "make-symbol": {
        "description": "pname - the symbol's print name string, returns - the new symbol", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-symbol", 
            "pname"
        ], 
        "declaration": "make-symbol(pname)", 
        "name": "make-symbol"
    }, 
    "fmosc": {
        "description": "Returns a sound which is table oscillated at pitch plus modulation for the duration of the sound modulation. osc-table defaults to *table*, and phase is the starting phase (default 0.0 degrees) within osc-table. The modulation is expressed in hz, e.g. a sinusoid modulation signal with an amplitude of 1.0 (2.0 peak to peak), will cause a +/- 1.0 hz frequency deviation in sound. Negative frequencies are correctly handled. The sample rate is *sound-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "fmosc", 
            "pitch", 
            "modulation", 
            "[", 
            "table", 
            "phase", 
            "]"
        ], 
        "declaration": "fmosc(pitch, modulation [, table,phase])", 
        "name": "fmosc"
    }, 
    "modalbar": {
        "description": "A physical model of a struck bar instrument implemented in STK. The parameter preset is one of the symbols MARIMBA, VIBRAPHONE, AGOGO, WOOD1, RESO, WOOD2, BEATS, TWO-FIXED, or CLUMP. The symbol must be quoted, e.g. for SAL syntax use quote(marimba), and for Lisp syntax use 'marimba. The parameter step is a FLONUM that sets the pitch (in steps), and dur is the duration in seconds.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "modalbar", 
            "preset", 
            "step", 
            "dur"
        ], 
        "declaration": "modalbar(preset, step, dur)", 
        "name": "modalbar"
    }, 
    "snd-fmfbv": {
        "description": "A Feedback FM oscillator. The resulting sound starts at t0, has a fundamental frequency of hz, and a sample rate of sr. The index is a SOUND that specifies the amount of feedback and determines the duration. You should use fmfb instead (see Section \"Oscillators\").", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "snd-fmfbv", 
            "t0", 
            "hz", 
            "sr", 
            "index", 
            "snd-fmfv", 
            "t0", 
            "hz", 
            "sr", 
            "index"
        ], 
        "declaration": "snd-fmfbv(t0, hz, sr, index), (snd-fmfv t0 hz sr index)", 
        "name": "snd-fmfbv"
    }, 
    "snd-tapf": {
        "description": "A variable delay like snd-tapv except there is no linear interpolation. By eliminating interpolation, the output is an exact copy of the input with no filtering or distortion. On the other hand, delays jump by samples causing samples to double or skip even when the delay is changed smoothly.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-tapf", 
            "sound", 
            "offset", 
            "vardelay", 
            "maxdelay"
        ], 
        "declaration": "snd-tapf(sound, offset, vardelay, maxdelay)", 
        "name": "snd-tapf"
    }, 
    "nband": {
        "description": "A graphical equalizer, identical to nband-range with a range of 20 to 20,000 Hz.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "nband", 
            "input", 
            "gains"
        ], 
        "declaration": "nband(input, gains)", 
        "name": "nband"
    }, 
    "defun": {
        "description": "sym - symbol being defined (quoted), fargs - formal argument list (lambda list) (quoted), expr - expressions constituting the body of the, function (quoted) returns - the function symbol", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "defun", 
            "sym", 
            "fargs", 
            "expr..."
        ], 
        "declaration": "(defun sym fargs expr...)", 
        "name": "defun"
    }, 
    "amosc": {
        "description": "Returns a sound which is table oscillated at pitch. The output is multiplied by modulation for the duration of the sound modulation. osc-table defaults to *table*, and phase is the starting phase (default 0.0 degrees) within osc-table. The sample rate is *sound-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "amosc", 
            "pitch", 
            "modulation", 
            "[", 
            "table", 
            "phase", 
            "]"
        ], 
        "declaration": "amosc(pitch, modulation [, table,phase])", 
        "name": "amosc"
    }, 
    "set-control-srate": {
        "description": "Sets the default sampling rate for control signals to rate by setting *default-control-srate* and reinitializing the environment. Do not call this within any synthesis function (see the control-srate-abs transformation, Section \"Transformations\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "set-control-srate", 
            "rate"
        ], 
        "declaration": "set-control-srate(rate)", 
        "name": "set-control-srate"
    }, 
    "pl-rear": {
        "description": "Produce a Dolby-encoded (stereo) signal with snd, a SOUND, encoded as the rear, or surround, channel.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pl-rear", 
            "snd"
        ], 
        "declaration": "pl-rear(snd)", 
        "name": "pl-rear"
    }, 
    "make-lpc-file-iterator": {
        "description": "Another way to get LPC frames is to read them from a file. This function opens an ASCII file containing LPC frames and creates an iterator object, an instance of class lpc-file-class to access them. Create a file using save-lpc-file (see below).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-lpc-file-iterator", 
            "filename"
        ], 
        "declaration": "make-lpc-file-iterator(filename)", 
        "name": "make-lpc-file-iterator"
    }, 
    "snd-tapv": {
        "description": "A variable delay: sound is delayed by the sum of offset (a FIXNUM or FLONUM) and vardelay (a SOUND). The specified delay is adjusted to lie in the range of zero to maxdelay seconds to yield the actual delay, and the delay is implemented using linear interpolation. This function was designed specifically for use in a chorus effect: the offset is set to half of maxdelay, and the vardelay input is a slow sinusoid. The maximum delay is limited to maxdelay, which determines the length of a fixed-sized buffer. The function tapv is equivalent and preferred (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-tapv", 
            "sound", 
            "offset", 
            "vardelay", 
            "maxdelay"
        ], 
        "declaration": "snd-tapv(sound, offset, vardelay, maxdelay)", 
        "name": "snd-tapv"
    }, 
    "member": {
        "description": "expr - the expression to find, list - the list to search, :test - the test function (defaults to eql), :test-not - the test function (sense inverted) , returns - the remainder of the list starting with the expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "member", 
            "expr", 
            "list", 
            "test:", 
            "test", 
            "test-not:", 
            "test-not"
        ], 
        "declaration": "member(expr, list, test: test, test-not: test-not)", 
        "name": "member"
    }, 
    "snd-osc": {
        "description": "A simple table lookup oscillator with fixed frequency. The duration is d seconds. You should use osc instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-osc", 
            "s", 
            "step", 
            "sr", 
            "hz", 
            "t0", 
            "d", 
            "phase"
        ], 
        "declaration": "snd-osc(s, step, sr, hz, t0, d, phase)", 
        "name": "snd-osc"
    }, 
    "pwlr-list": {
        "description": "A version of pwlr that takes a single list of breakpoints as its argument. See pwl-list above for the rationale.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwlr-list", 
            "breakpoints"
        ], 
        "declaration": "pwlr-list(breakpoints)", 
        "name": "pwlr-list"
    }, 
    "highpass8": {
        "description": "An eight-pole Butterworth highpass filter. The cutoff frequency is hz (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "highpass8", 
            "signal", 
            "hz"
        ], 
        "declaration": "highpass8(signal, hz)", 
        "name": "highpass8"
    }, 
    "*default-sf-bits*": {
        "description": "The default bits-per-sample for sound files. Typically 16.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*default-sf-bits*"
        ], 
        "declaration": "*default-sf-bits*", 
        "name": "*default-sf-bits*"
    }, 
    "numberp": {
        "description": "expr - the expression to check, returns - t if the expression is a number, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "numberp", 
            "expr"
        ], 
        "declaration": "numberp(expr)", 
        "name": "numberp"
    }, 
    "highpass4": {
        "description": "A four-pole Butterworth highpass filter. The cutoff frequency is hz (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "highpass4", 
            "signal", 
            "hz"
        ], 
        "declaration": "highpass4(signal, hz)", 
        "name": "highpass4"
    }, 
    "highpass6": {
        "description": "A six-pole Butterworth highpass filter. The cutoff frequency is hz (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "highpass6", 
            "signal", 
            "hz"
        ], 
        "declaration": "highpass6(signal, hz)", 
        "name": "highpass6"
    }, 
    "s-max": {
        "description": "Compute the maximum of two functions, sound1 and sound2. This function also accepts numbers and multichannel sounds and returns the corresponding data type. The start time of the result is the maximum of the start times of sound1 and sound2. The logical stop time and physical stop time of the result is the minimum of the logical stop and physical stop times respectively of sound1 and sound2. Note, therefore, that the result value is zero except within the bounds of both input sounds.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-max", 
            "sound1", 
            "sound2"
        ], 
        "declaration": "s-max(sound1, sound2)", 
        "name": "s-max"
    }, 
    "score-shift": {
        "description": "Add a constant offset to the starting time of a set of notes in score. By default, all notes are modified, but the range of notes can be limited with the keyword parameters. The begin time of the score is not changed, but the end time is increased by offset. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-shift", 
            "score", 
            "offset", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-shift(score, offset, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-shift"
    }, 
    "vel-to-linear": {
        "description": "Returns the conversion of x from MIDI velocity to linear amplitude ratio using a rule that maps MIDI velocity 1 to -60 dB (0.001) and 127 to unity gain. The amplitude is proportional to the square of MIDI velocity. The input x can be a FIXNUM or FLONUM but not a sound. The result is a FLONUM.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "vel-to-linear", 
            "x"
        ], 
        "declaration": "vel-to-linear(x)", 
        "name": "vel-to-linear"
    }, 
    "lp": {
        "description": "Filters sound using a first-order Butterworth low-pass filter. Cutoff may be a float or a signal (for time-varying filtering) and expresses hertz. Filter coefficients (requiring trig functions) are recomputed at the sample rate of cutoff. The resulting sample rate, start time, etc. are taken from sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lp", 
            "sound", 
            "cutoff"
        ], 
        "declaration": "lp(sound, cutoff)", 
        "name": "lp"
    }, 
    "snd-fetch-array": {
        "description": "Reads sequential arrays of samples from sound, returning either an array of FLONUMs or NIL when the sound terminates. The len parameter, a FIXNUM, indicates how many samples should be returned in the result array. After the array is returned, sound is modified by skipping over step (a FIXNUM) samples. If step equals len, then every sample is returned once. If step is less than len, each returned array will overlap the previous one, so some samples will be returned more than once. If step is greater than len, then some samples will be skipped and not returned in any array. The step and len may change at each call, but in the current implementation, an internal buffer is allocated for sound on the first call, so subsequent calls may not specify a greater len than the first. When an array is returned, it will have len samples. If necessary, snd-fetch-array will read zeros beyond the end of the sound to fill the array. When this happens, *rslt* is set to a FIXNUM number of samples in the array that were read from the sound before the physical stop time of the sound. If all samples in the array are \"valid\" samples from the sound (coming from the sound before the sound terminates), *rslt* is set to NIL. The *rslt* variable is global and used to return extra results from other functions, so programs should not assume *rslt* is valid after subsequent function calls. Note: snd-fetch-array modifies sound; it is strongly recommended to copy sound using snd-copy and access only the copy with snd-fetch-array.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-fetch-array", 
            "sound", 
            "len", 
            "step"
        ], 
        "declaration": "snd-fetch-array(sound, len,step)", 
        "name": "snd-fetch-array"
    }, 
    "hzosc": {
        "description": "Returns a sound which is the table oscillated at hz starting at phase degrees. The default table is *table* and the default phase is 0.0. The default duration is 1.0, but this is stretched as in osc (see above). The hz parameter may be a SOUND, in which case the duration of the result is the duration of hz. The sample rate is *sound-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "hzosc", 
            "hz", 
            "[", 
            "table", 
            "phase", 
            "]"
        ], 
        "declaration": "hzosc(hz [, table, phase])", 
        "name": "hzosc"
    }, 
    "remove-if-not": {
        "description": "test - the test predicate, list - the list, returns - copy of list with non-matching elements removed", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "remove-if-not", 
            "test", 
            "list"
        ], 
        "declaration": "remove-if-not(test, list)", 
        "name": "remove-if-not"
    }, 
    "return": {
        "description": "expr - the value (defaults to nil), returns - never returns", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "return", 
            "[", 
            "expr", 
            "]"
        ], 
        "declaration": "(return [expr])", 
        "name": "return"
    }, 
    "snd-set-logical-stop": {
        "description": "Returns a sound which is sound, except that the logical stop of the sound occurs at time. Note: do not call this function. When defining a behavior, use set-logical-stop or set-logical-stop-abs instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-set-logical-stop", 
            "sound", 
            "time"
        ], 
        "declaration": "snd-set-logical-stop(sound,time)", 
        "name": "snd-set-logical-stop"
    }, 
    "soften-clipping": {
        "description": "Filter the loud regions of a signal where clipping is likely to have generated additional high frequencies. The input signal is snd and cutoff is the filter cutoff frequency (4 kHz is recommended for speech).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "soften-clipping", 
            "snd", 
            "cutoff"
        ], 
        "declaration": "soften-clipping(snd, cutoff)", 
        "name": "soften-clipping"
    }, 
    "s-exp": {
        "description": "A generalized exponential function. If sound is a SOUND, compute e^(x) for each sample x. If sound is a number x, just compute e^(x). If sound is a multichannel sound, return a multichannel sound with s-exp applied to each element. The result has the type, sample rate, starting time, etc. of sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-exp", 
            "sound"
        ], 
        "declaration": "s-exp(sound)", 
        "name": "s-exp"
    }, 
    "flet": {
        "description": "binding - the function bindings each of which is:, (sym fargs expr...) where: sym - the function/macro name, fargs - formal argument list (lambda list), expr - expressions constituting the body of the function/macro expr - the expressions to be evaluated, returns - the value of the last expression", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "flet", 
            "binding...", 
            "expr..."
        ], 
        "declaration": "(flet (binding...) expr...)", 
        "name": "flet"
    }, 
    "break": {
        "description": "bmsg - the break message string (defaults to **break**), arg - the argument expression (printed after the message), returns - nil when continued from the break loop", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "break", 
            "[", 
            "bmsg", 
            "[", 
            "arg", 
            "]", 
            "]"
        ], 
        "declaration": "break([bmsg [, arg]])", 
        "name": "break"
    }, 
    "nstring-upcase": {
        "description": "str - the string, :start - the starting offset, :end - the ending offset + 1, returns - the converted string (not a copy)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "nstring-upcase", 
            "str", 
            "start:", 
            "start", 
            "end:", 
            "end"
        ], 
        "declaration": "nstring-upcase(str, start: start, end: end)", 
        "name": "nstring-upcase"
    }, 
    "not": {
        "description": "expr - the expression to check, return - t if the value is nil, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "not", 
            "expr"
        ], 
        "declaration": "not(expr)", 
        "name": "not"
    }, 
    "areson": {
        "description": "The areson filter is an exact complement of reson such that if both are applied to the same signal with the same parameters, the sum of the results yeilds the original signal.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "areson", 
            "sound", 
            "center", 
            "bandwidth", 
            "n"
        ], 
        "declaration": "areson(sound, center, bandwidth, n)", 
        "name": "areson"
    }, 
    "pwevr": {
        "description": "Creates a piece-wise exponential envelope with breakpoints at (0, l1), (t2, l2), etc., ending with (tn, ln, where tj is the sum of i2 through ij. In other words, the breakpoint times are specified in terms of intervals rather than cummulative time. Otherwise, the behavior is like that of pwev. Note that this is similar to the csound GEN05 generator. Which is uglier, GEN05 or pwevr?", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwevr", 
            "l1", 
            "i2", 
            "l2", 
            "i3", 
            "i3", 
            "...", 
            "in", 
            "ln"
        ], 
        "declaration": "pwevr(l1, i2, l2, i3, i3, ... in, ln)", 
        "name": "pwevr"
    }, 
    "s-reverse": {
        "description": "Reverses snd (a SOUND). Sound must be shorter than *max-reverse-samples*, which is currently initialized to 25 million samples. Reversal allocates about 4 bytes per sample. This function uses XLISP in the inner sample loop, so do not be surprised if it calls the garbage collector a lot and runs slowly. The result starts at the starting time given by the current environment (not necessarily the starting time of snd). If snd has multiple channels, a multiple channel, reversed sound is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-reverse", 
            "snd"
        ], 
        "declaration": "s-reverse(snd)", 
        "name": "s-reverse"
    }, 
    "string-search": {
        "description": "pat - a string to search for, str - the string to be searched, :start - the starting offset in str, :end - the ending offset + 1, returns - index of pat in str or NIL if not found", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string-search", 
            "pat", 
            "str", 
            "start:", 
            "start", 
            "end:", 
            "end"
        ], 
        "declaration": "string-search(pat, str, start: start, end: end)", 
        "name": "string-search"
    }, 
    "score-append": {
        "description": "Create a new score containing all the notes of the parameters, which are all scores. The begin time of the first score is unaltered. The begin time of each other score is aligned to the end time of the previous score; thus, scores are \"spliced\" in sequence. The original scores are not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-append", 
            "score1", 
            "score2", 
            "..."
        ], 
        "declaration": "score-append(score1, score2, ...)", 
        "name": "score-append"
    }, 
    "snd-srate": {
        "description": "Returns the sample rate of the sound. Safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-srate", 
            "sound"
        ], 
        "declaration": "snd-srate(sound)", 
        "name": "snd-srate"
    }, 
    "string-trim": {
        "description": "bag - a string containing characters to trim, str - the string to trim, returns - a trimed copy of the string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string-trim", 
            "bag", 
            "str"
        ], 
        "declaration": "string-trim(bag, str)", 
        "name": "string-trim"
    }, 
    "snd-oneshot": {
        "description": "Computes a new sound that is zero except where sound exceeds threshold. From these points, the result is 1.0 until sound remains below threshold for ontime (in seconds). The result has the same sample rate, start time, logical stop time, and duration as sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-oneshot", 
            "sound", 
            "threshold", 
            "ontime"
        ], 
        "declaration": "snd-oneshot(sound, threshold, ontime)", 
        "name": "snd-oneshot"
    }, 
    "make-lpanal-iterator": {
        "description": "Makes an iterator object, an instance of lpanal-class, that returns LPC frames from successive frames of samples in sound. The duration (in seconds) of each frame is given by framedur, a FLONUM. The skip size (in seconds) between successive frames is given by skiptime, a FLONUM. Typical values for framedur and skiptime are 0.08 and 0.04, giving 25 frames per second and a 50% frame overlap. The number of poles is given by npoles, a FIXNUM. The result is an object that responds to the :next selector by returning a frame as described above. NIL is returned when sound terminates. (Note that one or more of the last analysis windows may be padded with zeros. NIL is only returned when the corresponding window would begin after the termination time of the sound.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-lpanal-iterator", 
            "sound", 
            "framedur", 
            "skiptime", 
            "npoles"
        ], 
        "declaration": "make-lpanal-iterator(sound, framedur, skiptime, npoles)", 
        "name": "make-lpanal-iterator"
    }, 
    "reverb": {
        "description": "Artificial reverberation applied to snd with a decay time of time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "reverb", 
            "snd", 
            "time"
        ], 
        "declaration": "reverb(snd, time)", 
        "name": "reverb"
    }, 
    "profile": {
        "description": "flag - nil turns profiling off, otherwise on, returns - the previous state of profiling.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "profile", 
            "flag"
        ], 
        "declaration": "profile(flag)", 
        "name": "profile"
    }, 
    "db-to-vel": {
        "description": "Returns the conversion of x from decibels to MIDI velocity using a rule that maps 0 dB to MIDI velocity 127 and -60 dB to MIDI velocity 1. The MIDI velocity is proportional to the square root of the amplitude. The input x can be a FIXNUM or FLONUM but not a sound. The result is a FLONUM.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "db-to-vel", 
            "x"
        ], 
        "declaration": "db-to-vel(x)", 
        "name": "db-to-vel"
    }, 
    "length-of-beat": {
        "description": "Given a tempo of bpm, return the duration of the beat in seconds. Note that this software has no real notion of beat. A \"beat\" is just the duration of each character in the beat pattern strings. This function returns a FLONUM.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "length-of-beat", 
            "bpm"
        ], 
        "declaration": "length-of-beat(bpm)", 
        "name": "length-of-beat"
    }, 
    "lfo": {
        "description": "Just like osc (below) except this computes at the *control-srate* and frequency is specified in Hz. Phase is specified in degrees. The *transpose* and *sustain* is not applied. The effect of time warping is to warp the starting and ending times. The signal itself will have a constant unwarped frequency.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lfo", 
            "freq", 
            "[", 
            "duration", 
            "table", 
            "phase", 
            "]"
        ], 
        "declaration": "lfo(freq [, duration, table, phase])", 
        "name": "lfo"
    }, 
    "hyperbolic-cosine-dist": {
        "description": "Returns a FLONUM value from the hyperbolic cosine distribution, a symetric distribution with its peak at zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "hyperbolic-cosine-dist", 
            "[", 
            "low", 
            "high", 
            "]"
        ], 
        "declaration": "hyperbolic-cosine-dist([low, high])", 
        "name": "hyperbolic-cosine-dist"
    }, 
    "snd-lpreson": {
        "description": "This function is identical to lpreson (see above).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-lpreson", 
            "snd", 
            "lpc-iterator", 
            "skiptime"
        ], 
        "declaration": "snd-lpreson(snd, lpc-iterator, skiptime)", 
        "name": "snd-lpreson"
    }, 
    "pl-center": {
        "description": "Produce a Dolby-encoded (stereo) signal with snd, a SOUND, encoded as the front center channel.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pl-center", 
            "snd"
        ], 
        "declaration": "pl-center(snd)", 
        "name": "pl-center"
    }, 
    "soundp": {
        "description": "Returns true iff sound is a SOUND. Safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "soundp", 
            "sound"
        ], 
        "declaration": "soundp(sound)", 
        "name": "soundp"
    }, 
    "evenp": {
        "description": "expr - the integer to test, returns - t if the integer is even, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "evenp", 
            "expr"
        ], 
        "declaration": "evenp(expr)", 
        "name": "evenp"
    }, 
    "extract": {
        "description": "Returns a sound which is the portion of beh between start and stop. Note that this is done relative to the current *warp*. The result is shifted to start according to *warp*, so normally the result will start without a delay of start.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "extract", 
            "start", 
            "stop", 
            "beh"
        ], 
        "declaration": "extract(start, stop, beh)", 
        "name": "extract"
    }, 
    "*default-plot-file*": {
        "description": "The file containing the data points, defaults to \"points.dat\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*default-plot-file*"
        ], 
        "declaration": "*default-plot-file*", 
        "name": "*default-plot-file*"
    }, 
    "snd-atonev": {
        "description": "This is just like snd-atone except that the hz cutoff frequency is a sound. Filter coefficients are updated at the sample rate of hz. You should use hp instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-atonev", 
            "sound", 
            "hz"
        ], 
        "declaration": "snd-atonev(sound, hz)", 
        "name": "snd-atonev"
    }, 
    "snd-stkchorus": {
        "description": "A chorus implemented in STK. The parameter delay is a FIXNUM representing the median desired delay length in samples. A typical value is 6000. The FLONUM parameters depth and freq set the modulation depth (from 0 to 1) and modulation frequency (in Hz), mix sets the mixture of input sound and chorused sound, where a value of 0.0 means input sound only (dry) and a value of 1.0 means chorused sound only (wet). You should use pitshift instead (see Section \"Effects\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-stkchorus", 
            "sound", 
            "delay", 
            "depth", 
            "freq", 
            "mix"
        ], 
        "declaration": "snd-stkchorus(sound, delay, depth, freq, mix)", 
        "name": "snd-stkchorus"
    }, 
    "evalhook": {
        "description": "expr - the expression to evaluate, ehook - the value for *evalhook*, ahook - the value for *applyhook*, env - the environment (default is nil), returns - the result of evaluating the expression", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "evalhook", 
            "expr", 
            "ehook", 
            "ahook", 
            "[", 
            "env", 
            "]"
        ], 
        "declaration": "(evalhook expr ehook ahook [env])", 
        "name": "evalhook"
    }, 
    "piano-note": {
        "description": "Synthesizes a piano tone. Duration is the duration to the point of key release, after which there is a rapid decay. Step is the pitch in half steps, and dynamic is approximately equivalent to a MIDI key velocity parameter. Use a value near 100 for a loud sound and near 10 for a soft sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "piano-note", 
            "duration", 
            "step", 
            "dynamic"
        ], 
        "declaration": "piano-note(duration, step,  dynamic)", 
        "name": "piano-note"
    }, 
    "princ": {
        "description": "expr - the expressions to be printed, stream - the output stream (default is standard output), returns - the expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "princ", 
            "expr", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "princ(expr [, stream])", 
        "name": "princ"
    }, 
    "force-srate": {
        "description": "Returns a sound which is up- or down-sampled to srate. Interpolation is linear, and no prefiltering is applied in the down-sample case, so aliasing may occur. See also resample.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "force-srate", 
            "srate", 
            "sound"
        ], 
        "declaration": "force-srate(srate, sound)", 
        "name": "force-srate"
    }, 
    "vector": {
        "description": "expr - the vector elements, returns - the new vector", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "vector", 
            "expr..."
        ], 
        "declaration": "vector(expr...)", 
        "name": "vector"
    }, 
    "sustain": {
        "description": "Evaluates beh with *sustain* scaled by factor. The effect is to \"stretch\" the result of beh (under the current environment) by factor; however, the logical stop times are not stretched. Therefore, the overall duration of a sequence is not changed, and sounds will tend to overlap if *sustain* is greater than one (legato) and be separated by silence if *sustain* is less than one.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sustain", 
            "factor", 
            "beh"
        ], 
        "declaration": "sustain(factor, beh)", 
        "name": "sustain"
    }, 
    "snd-delay": {
        "description": "Feedback delay. The output, initially sound, is recursively delayed by delay, scaled by feedback, and added to itself, producing an repeating echo effect. The feedback should be less than one to avoid exponential amplitude blowup. Delay is rounded to the nearest sample. You should use feedback-delay instead (see Section \"Filter Behaviors\")", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-delay", 
            "sound", 
            "delay", 
            "feedback"
        ], 
        "declaration": "snd-delay(sound, delay, feedback)", 
        "name": "snd-delay"
    }, 
    "pan": {
        "description": "Pans sound (a behavior) according to where (another behavior or a number). Sound must be monophonic. Where may be a monophonic sound (e.g. (ramp) or simply a number (e.g. 0.5). In either case, where should range from 0 to 1, where 0 means pan completely left, and 1 means pan completely right. For intermediate values, the sound to each channel is scaled linearly. Presently, pan does not check its arguments carefully.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pan", 
            "sound", 
            "where"
        ], 
        "declaration": "pan(sound, where)", 
        "name": "pan"
    }, 
    "print": {
        "description": "expr - the expression to be printed, stream - the output stream (default is standard output), returns - the expression", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "print", 
            "expr", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "(print expr [stream])", 
        "name": "print"
    }, 
    "string-left-trim": {
        "description": "bag - a string containing characters to trim, str - the string to trim, returns - a trimed copy of the string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string-left-trim", 
            "bag", 
            "str"
        ], 
        "declaration": "string-left-trim(bag, str)", 
        "name": "string-left-trim"
    }, 
    "snd-tonev": {
        "description": "This function is identical to snd-tone except hz (cutoff frequency) is a sound. The filter coefficients are updated at the sample rate of hz. You should use lp instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-tonev", 
            "sound", 
            "hz"
        ], 
        "declaration": "snd-tonev(sound, hz)", 
        "name": "snd-tonev"
    }, 
    "midi-show-file": {
        "description": "Print the contents of a MIDI file to the console.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "midi-show-file", 
            "file-name"
        ], 
        "declaration": "midi-show-file(file-name)", 
        "name": "midi-show-file"
    }, 
    "*default-sf-srate*": {
        "description": "The default sample rate for sound files. Typically 44100.0, but often set to 22050.0 for speed in non-critical tasks.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*default-sf-srate*"
        ], 
        "declaration": "*default-sf-srate*", 
        "name": "*default-sf-srate*"
    }, 
    "args": {
        "description": "Similar to grindef, this function prints the arguments to a function. This may be faster than looking up a function in the documentation if you just need a reminder. For example, (args 'lp) prints \"(LP S C),\" which may help you to remember that the arguments are a sound (S) followed by the cutoff (C) frequency.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "args", 
            "name"
        ], 
        "declaration": "args(name)", 
        "name": "args"
    }, 
    "char-downcase": {
        "description": "chr - the character, returns - the lower case character", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "char-downcase", 
            "chr"
        ], 
        "declaration": "char-downcase(chr)", 
        "name": "char-downcase"
    }, 
    "nth": {
        "description": "n - the number of the element to return (zero origin), list - the list, returns - the nth element or nil if the list isn't that long", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "nth", 
            "n", 
            "list"
        ], 
        "declaration": "nth(n, list)", 
        "name": "nth"
    }, 
    "pwer-list": {
        "description": "A version of pwer that takes a single list of breakpoints as its argument. See pwl-list above for the rationale.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwer-list", 
            "breakpoints"
        ], 
        "declaration": "pwer-list(breakpoints)", 
        "name": "pwer-list"
    }, 
    "sref": {
        "description": "Accesses sound at the point time, which is a local time. If time does not correspond to a sample time, then the nearest samples are linearly interpolated to form the result. To access a particular sample, either convert the sound to an array (see snd-samples below), or use snd-srate and snd-t0 (see below) to find the sample rate and starting time, and compute a time (t) from the sample number (n): t = (n / srate) + t0 Thus, the lisp code to access the n^(th) sample of a sound would look like: (sref sound (global-to-local (+ (/ n (snd-srate sound)) (snd-t0 sound)))) Here is why sref interprets its time argument as a local time: (sref (ramp 1) 0.5) ; evaluate a ramp at time 0.5 0.5 (at 2.0 (sref (ramp 1) 0.5)) ; ramp is shifted to start at 2.0 ; the time, 0.5, is shifted to 2.5 0.5 If you were to use snd-sref, which treats time as global, instead of sref, which treats time as local, then the first example above would return the same answer (0.5), but the second example would return 0. Why? Because the (ramp 1) behavior would be shifted to start at time 2.0, but the resulting sound would be evaluated at global time 0.5. By definition, sounds have a value of zero before their start time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sref", 
            "sound", 
            "time"
        ], 
        "declaration": "sref(sound, time)", 
        "name": "sref"
    }, 
    "score-must-have-begin-end": {
        "description": "If score does not have a begin and end time, construct a score with a SCORE-BEGIN-END expression and return it. If score already has a begin and end time, just return the score. The orignal score is not modified.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-must-have-begin-end", 
            "score"
        ], 
        "declaration": "score-must-have-begin-end(score)", 
        "name": "score-must-have-begin-end"
    }, 
    "score-select": {
        "description": "Select (or reject) notes to form a new score. Notes are selected if they fall into the given ranges of index and time and they satisfy predicate, a function of three parameters that is applied to the start time, duration, and the expression of the note. Alternatively, predicate may be t, indicating that all notes in range are to be selected. The selected notes along with the existing score begin and end markers, are combined to form a new score. Alternatively, if the reject: parameter is non-null, the notes not selected form the new score (in other words the selected notes are rejected or removed to form the new score). The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-select", 
            "score", 
            "predicate", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y", 
            "reject:", 
            "flag"
        ], 
        "declaration": "score-select(score, predicate, from-index: i, to-index: j, from-time: x, to-time: y, reject: flag)", 
        "name": "score-select"
    }, 
    "make-heap": {
        "description": "Generate items randomly from list without replacement. If max is 1, the first element of a new period will not be the same as the last element of the previous period, avoiding repetition. The default value of max is 2, meaning repetition is allowed. The period length is the length of items. If items is a pattern, a period from that pattern becomes the list from which random selections are made, and a new list is generated every period.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-heap", 
            "items", 
            "for:", 
            "for", 
            "max:", 
            "max", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-heap(items, for: for, max: max, name: name, trace: trace)", 
        "name": "make-heap"
    }, 
    "pl-right": {
        "description": "Produce a Dolby-encoded (stereo) signal with snd, a SOUND, encoded as the front right channel.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pl-right", 
            "snd"
        ], 
        "declaration": "pl-right(snd)", 
        "name": "pl-right"
    }, 
    "baktrace": {
        "description": "n - the number of levels (defaults to all levels), returns - nil", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "baktrace", 
            "[", 
            "n", 
            "]"
        ], 
        "declaration": "(baktrace [n])", 
        "name": "baktrace"
    }, 
    "get-duration": {
        "description": "Gets the actual duration of of something starting at a local time of 0 and ending at a local time of dur times the current sustain. For convenience, *rslt* is set to the global time corresponding to local time zero.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-duration", 
            "dur"
        ], 
        "declaration": "get-duration(dur)", 
        "name": "get-duration"
    }, 
    "putprop": {
        "description": "sym - the symbol, val - the property value, prop - the property symbol, returns - the property value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "putprop", 
            "sym", 
            "val", 
            "prop"
        ], 
        "declaration": "putprop(sym, val, prop)", 
        "name": "putprop"
    }, 
    "sound-srate-abs": {
        "description": "Evaluate beh with *sound-srate* set to sample rate srate. Note: there is no \"relative\" version of this function.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sound-srate-abs", 
            "srate", 
            "beh"
        ], 
        "declaration": "sound-srate-abs(srate, beh)", 
        "name": "sound-srate-abs"
    }, 
    "control-srate-abs": {
        "description": "Evaluate beh with *control-srate* set to sample rate srate. Note: there is no \"relative\" version of this function.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "control-srate-abs", 
            "srate", 
            "beh"
        ], 
        "declaration": "control-srate-abs(srate, beh)", 
        "name": "control-srate-abs"
    }, 
    "snd-sax-all": {
        "description": "A sax model just like snd-sax-freq but with additional parameters for vibrato generation and continuous control of reed stiffness, breath noise, excitation position, and reed table offset. You should use sax-all instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sax-all", 
            "freq", 
            "vibrato-freq", 
            "vibrato-gain", 
            "freq-env", 
            "breath-env", 
            "reed-stiffness", 
            "noise", 
            "blow-pos", 
            "reed-table-offset", 
            "sr"
        ], 
        "declaration": "snd-sax-all(freq, vibrato-freq,vibrato-gain, freq-env, breath-env,reed-stiffness, noise, blow-pos, reed-table-offset, sr)", 
        "name": "snd-sax-all"
    }, 
    "snd-length": {
        "description": "Counts the number of samples in sound up to the physical stop time. If the sound has more than maxlen samples, maxlen is returned. Calling this function will cause all samples of the sound to be computed and saved in memory (about 4 bytes per sample). Otherwise, this function is safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-length", 
            "sound", 
            "maxlen"
        ], 
        "declaration": "snd-length(sound, maxlen)", 
        "name": "snd-length"
    }, 
    "read-line": {
        "description": "stream - the input stream (default is standard input), returns - the string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "read-line", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "read-line([stream])", 
        "name": "read-line"
    }, 
    "snd-mandolin": {
        "description": "A plucked double-string instrument model implemented in STK. The t0 parameter is the starting time (in seconds), freq is a FLONUM in Hz, body-size and detune are FLONUMs, and sr is the desired sample rate. You should use mandolin instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-mandolin", 
            "t0", 
            "freq", 
            "dur", 
            "body-size", 
            "detune", 
            "sr"
        ], 
        "declaration": "snd-mandolin(t0, freq, dur, body-size, detune, sr)", 
        "name": "snd-mandolin"
    }, 
    "snd-multiseq": {
        "description": "This function is similar to snd-seq except the first parameter is a multichannel sound rather than a single sound. A multichannel sound is simply an XLISP array of sounds. An array of sounds is returned which is the sum of array and another array of sounds returned by closure. The closure is passed the logical stop time of the multichannel sound, which is the maximum logical stop time of any element of array. Do not call this function. See seq in Section \"Combination and Time Structure\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-multiseq", 
            "array", 
            "closure"
        ], 
        "declaration": "snd-multiseq(array, closure)", 
        "name": "snd-multiseq"
    }, 
    "loud": {
        "description": "Evaluates beh with *loud* incremented by volume. (Recall that *loud* is in decibels, so increment is the proper operation.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "loud", 
            "volume", 
            "beh"
        ], 
        "declaration": "loud(volume, beh)", 
        "name": "loud"
    }, 
    "prin1": {
        "description": "expr - the expression to be printed, stream - the output stream (default is standard output), returns - the expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "prin1", 
            "expr", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "prin1(expr [, stream])", 
        "name": "prin1"
    }, 
    "pwevr-list": {
        "description": "A version of pwevr that takes a single list of breakpoints as its argument. See pwl-list above for the rationale.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwevr-list", 
            "breakpoints"
        ], 
        "declaration": "pwevr-list(breakpoints)", 
        "name": "pwevr-list"
    }, 
    "prog1": {
        "description": "expr1 - the first expression to evaluate, expr - the remaining expressions to evaluate, returns - the value of the first expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "prog1", 
            "expr1", 
            "expr..."
        ], 
        "declaration": "prog1(expr1, expr...)", 
        "name": "prog1"
    }, 
    "snd-stkrev": {
        "description": "A reverb implemented in STK. The parameter rev-type is a FIXNUM ranging from zero to two and selects the type of reverb. Zero selects NRev type, one selects JCRev, and two selects PRCRev. The input sound is processed by the reverb with a decay time in seconds (a FLONUM). The mix, a FLONUM, sets the mixture of dry input and reverb output. A value of 0.0 means input only (dry) and a value of 1.0 means reverb only (wet). The sample rate is that of sound. You should use nrev, jcrev or prcrev instead (see Section \"Effects\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-stkrev", 
            "rev-type", 
            "sound", 
            "decay", 
            "mix"
        ], 
        "declaration": "snd-stkrev(rev-type, sound, decay, mix)", 
        "name": "snd-stkrev"
    }, 
    "score-gen": {
        "description": "where the k's are keywords and the e's are expressions. A score is generated by evaluating the expressions once for each note and constructing a list of keyword-value pairs. A number of keywords have special interpretations. The rules for interpreting these parameters will be explained through a set of \"How do I ...\" questions below.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-gen", 
            "k1:", 
            "e1", 
            "k2:", 
            "e2", 
            "..."
        ], 
        "declaration": "score-gen(k1: e1, k2: e2, ...)", 
        "name": "score-gen"
    }, 
    "alpass": {
        "description": "Applies an all-pass filter to sound. This all-pass filter creates a delay effect without the resonances of a comb filter. The decay time of the filter is given by decay. The hz parameter must be a number or sound greater than zero. It is used to compute delay, which is then rounded to the nearest integer number of samples (so the frequency is not always exact. Higher sampling rates yield better delay resolution.) The decay may be a sound or a number. In either case, it must also be positive. (Implementation note: an exponentiation is needed to convert decay into the feedback parameter, and exponentiation is typically more time-consuming than the filter operation itself. To get high performance, provide decay at a low sample rate.) The resulting sound will have the start time, sample rate, etc. of sound. If hz is of type SOUND, the delay may be time-varying. Linear interpolation is then used for fractional sample delay, but it should be noted that linear interpolation implies a low-pass transfer function. Thus, this filter may behave differently with a constant SOUND than it does with a FLONUM value for hz. In addition, if hz is of type SOUND, then minhz is required. The hz parameter will be clipped to be greater than minhz, placing an upper bound on the delay buffer length.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "alpass", 
            "sound", 
            "decay", 
            "hz", 
            "[", 
            "minhz", 
            "]"
        ], 
        "declaration": "alpass(sound, decay, hz [, minhz])", 
        "name": "alpass"
    }, 
    "make-palindrome": {
        "description": "Generate items from list alternating in-order and reverse-order sequencing. The keyword parameter elide can have the values :first, :last, t, or nil to control repetition of the first and last elements. The elide parameter can also be a pattern, in which case it is evaluated every period. One period is one complete forward and backward traversal of the list. If items is a pattern, a period from that pattern becomes the list from which random selections are made, and a new list is generated every period.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-palindrome", 
            "items", 
            "elide:", 
            "elide", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-palindrome(items, elide: elide, for: for, name: name, trace: trace)", 
        "name": "make-palindrome"
    }, 
    "pwev-list": {
        "description": "A version of pwev that takes a single list of breakpoints as its argument. See pwl-list above for the rationale.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwev-list", 
            "breakpoints"
        ], 
        "declaration": "pwev-list(breakpoints)", 
        "name": "pwev-list"
    }, 
    "event-expression": {
        "description": "Retrieve the expression field from an event.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-expression", 
            "event"
        ], 
        "declaration": "event-expression(event)", 
        "name": "event-expression"
    }, 
    "autonorm-on": {
        "description": "Enable automatic adjustment of a scale factor applied to sounds computed using the play command.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "autonorm-on"
        ], 
        "declaration": "autonorm-on()", 
        "name": "autonorm-on"
    }, 
    "snd-fft": {
        "description": "This function performs an FFT on the first samples in sound and returns a Lisp array of FLONUMs. The function modifies the sound, violating the normal rule that sounds are immutable in Nyquist, so it is advised that you copy the sound using snd-copy if there are any other references to sound. The length of the FFT is specified by length, a FIXNUM (integer) which must be a power of 2. After each FFT, the sound is advanced by skip samples, also of type FIXNUM. Overlapping FFTs, where skip is less than length, are allowed. If window is not NIL, it must be a sound. The first length samples of window are multiplied by length samples of sound before performing the FFT. When there are no more samples in sound to transform, this function returns NIL. The coefficients in the returned array, in order, are the DC coefficient, the first real, the first imaginary, the second real, the second imaginary, etc. The last array element corresponds to the real coefficient at the Nyquist frequency.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-fft", 
            "sound", 
            "length", 
            "skip", 
            "window"
        ], 
        "declaration": "snd-fft(sound, length, skip, window)", 
        "name": "snd-fft"
    }, 
    "lower-case-p": {
        "description": "chr - the character, returns - t if the character is lower case, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lower-case-p", 
            "chr"
        ], 
        "declaration": "lower-case-p(chr)", 
        "name": "lower-case-p"
    }, 
    "snd-alpass": {
        "description": "An all-pass filter. This produces a repeating echo effect without the resonances of snd-delay. The feedback should be less than one to avoid exponential amplitude blowup. Delay is rounded to the nearest sample. You should use alpass instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-alpass", 
            "sound", 
            "delay", 
            "feedback"
        ], 
        "declaration": "snd-alpass(sound, delay, feedback)", 
        "name": "snd-alpass"
    }, 
    "open": {
        "description": "fname - the file name string or symbol, :direction - :input or :output (default is :input), returns - a stream", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "open", 
            "fname", 
            "direction:", 
            "direction"
        ], 
        "declaration": "open(fname, direction: direction)", 
        "name": "open"
    }, 
    "snd-chase": {
        "description": "A slew rate limiter. The output \"chases\" the input at rates determined by risetime and falltime. If the input changes too fast, the output will lag behind the input. This is a form of lowpass filter, but it was created to turn hard-switching square waves into smoother control signals that could be used for linear crossfades. If the input switches from 0 to 1, the output will linearly rise to 1 in risetime seconds. If the input switches from 1 to 0, the output will linearly fall to 0 in falltime seconds. The generated slope is constant; the transition is linear; this is not an exponential rise or fall. The risetime and falltime must be scalar constants; complain to the author if this is not adequate. The snd-chase function is safe for ordinary use. See snd-follow in Section \"Signal Operations\" for a related function.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-chase", 
            "sound", 
            "risetime", 
            "falltime"
        ], 
        "declaration": "snd-chase(sound, risetime, falltime)", 
        "name": "snd-chase"
    }, 
    "snd-tone": {
        "description": "A first-order recursive low-pass filter, based on the tone unit generator of Csound. The hz parameter is the cutoff frequency, the response curve's half-power point. The result sample rate, start time, etc. are takend from sound. You should use lp instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-tone", 
            "sound", 
            "hz"
        ], 
        "declaration": "snd-tone(sound, hz)", 
        "name": "snd-tone"
    }, 
    "make-window": {
        "description": "Make a pattern of class window-class that regroups items generated by a pattern according to pattern lengths given by length-pattern and where the period advances by the number of items given by skip-pattern. Note that length-pattern is not optional: There is no default pattern length and no for: keyword.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-window", 
            "pattern", 
            "length-pattern", 
            "skip-pattern", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-window(pattern, length-pattern, skip-pattern, name: name, trace: trace)", 
        "name": "make-window"
    }, 
    "get-slider-value": {
        "description": "Return the current value of the slider named by index (an integer index into the array of sliders). Note that this \"slider\" is just a floating point value in an array. Sliders can be changed by OSC messages (see osc-enable) and by sending character sequences to Nyquist's standard input. (Normally, these character sequences would not be typed but generated by the NyquistIDE interactive development environment, which runs Nyquist as a sub-process, and which present the user with graphical sliders.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-slider-value", 
            "index"
        ], 
        "declaration": "get-slider-value(index)", 
        "name": "get-slider-value"
    }, 
    "exponential-dist": {
        "description": "Return a FLONUM value from an exponential distribution. The initial downward slope is steeper with larger values of delta, which must be greater than zero. (See Figure 8. The optional high parameter puts an artificial upper bound on the return value. The exponential distribution generates values greater than 0, and can be used to generate time intervals. Natural random intervals such as the time intervals between the release of atomic particles or the passing of yellow volkswagons in traffic have exponential distributions. The exponential distribution is memory-less: knowing that a random number from this distribution is greater than some value (e.g. a note duration is at least 1 second) tells you nothing new about how soon the note will end. This is a continuous distribution, but geometric-dist (described below) implements the discrete form.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "exponential-dist", 
            "delta", 
            "[", 
            "high", 
            "]"
        ], 
        "declaration": "exponential-dist(delta [, high])", 
        "name": "exponential-dist"
    }, 
    "geometric-dist": {
        "description": "Returns a FIXNUM value from the geometric distribution, which is defined as the number of failures before a success is achieved in a Bernoulli trial with probability of success p (a FLONUM from 0 to 1).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "geometric-dist", 
            "p"
        ], 
        "declaration": "geometric-dist(p)", 
        "name": "geometric-dist"
    }, 
    "yin": {
        "description": "Fundamental frequency estimation (pitch detection. Use the YIN algorithm to estimate the fundamental frequency of sound, which must be a SOUND. The minstep, a FLONUM, is the minimum frequency considered (in steps), maxstep, a FLONUM, is the maximum frequency considered (in steps), and stepsize, a FIXNUM, is the desired hop size. The result is a \"stereo\" signal, i.e. an array of two SOUNDs, both at the same sample rate, which is approximately the sample rate of sound divided by stepsize. The first SOUND consists of frequency estimates (in units of steps, i.e. middle C = 60). The second sound consists of values that measure the confidence or reliability of the frequency estimate. A small value (less than 0.1) indicates fairly high confidence. A larger value indicates lower confidence. This number can also be thought of as a ratio of non-periodic power to periodic power. When the number is low, it means the signal is highly periodic at that point in time, so the period estimate will be reliable. Hint #1: See Alain de Cheveigne and Hideki Kawahara's article \"YIN, a Fundamental Frequency Estimator for Speech and Music\" in the Journal of the Acoustic Society of America, April 2002 for details on the yin algorithm. Hint #2: Typically, the stepsize should be at least the expected number of samples in one period so that the fundamental frequency estimates are calculated at a rate far below the sample rate of the signal. Frequency does not change rapidly and the yin algorithm is fairly slow. To optimize speed, you may want to use less than 44.1 kHz sample rates for input sounds. Yin uses interpolation to achieve potentially fractional-sample-accurate estimates, so higher sample rates do not necessarily help the algorithm and definitely slow it down. The computation time is O(n^(2)) per estimate, where n is the number of samples in the longest period considered. Therefore, each increase of minstep by 12 (an octave) gives you a factor of 4 speedup, and each decrease of the sample rate of sound by a factor of two gives you another factor of 4 speedup. Finally, the number of estimates is inversely proportional to stepsize. Hint #3: Use snd-srate (see Section \"Accessing and Creating Sound\") to get the exact sample rate of the result, which will be the sample rate of sound divided by stepsize. E.g. (snd-srate (aref yin-output 0)), where yin-output is a result returned by yin, will be the sample rate of the estimates.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "yin", 
            "sound", 
            "minstep", 
            "maxstep", 
            "stepsize"
        ], 
        "declaration": "yin(sound, minstep, maxstep, stepsize)", 
        "name": "yin"
    }, 
    "write-float": {
        "description": "ch - the character to write, stream - the output stream (default is standard output), length - the length of the float in bytes (default is 4, legal values are -4, -8, 4, and 8), returns - the integer, Note: Floats are assumed to be big-endian (high-order byte first) and signed, regardless of the platform. To write in little-endian format, use a negative number for the length, e.g. -4 indicates a 4-bytes, low-order byte first. The file should be opened in binary mode.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "write-float", 
            "ch", 
            "[", 
            "stream", 
            "[", 
            "length", 
            "]", 
            "]"
        ], 
        "declaration": "write-float(ch [, stream [, length]])", 
        "name": "write-float"
    }, 
    "eql": {
        "description": "expr1 - the first expression, expr2 - the second expression, returns - t if they are equal, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "eql", 
            "expr1", 
            "expr2"
        ], 
        "declaration": "eql(expr1, expr2)", 
        "name": "eql"
    }, 
    "*breakenable*": {
        "description": "Controls whether XLISP enters a break loop when an error is encountered. See Section \"Profiling\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*breakenable*"
        ], 
        "declaration": "*breakenable*", 
        "name": "*breakenable*"
    }, 
    "snd-fmfb": {
        "description": "A Feedback FM oscillator. The resulting sound starts at t0, has a fundamental frequency of hz, a sample rate of sr, and a duration of dur seconds. The index is a FLONUM that specifies the amount of feedback. You should use fmfb instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-fmfb", 
            "t0", 
            "hz", 
            "sr", 
            "index", 
            "dur"
        ], 
        "declaration": "snd-fmfb(t0, hz, sr, index, dur)", 
        "name": "snd-fmfb"
    }, 
    "logistic-dist": {
        "description": "Returns a FLONUM value from the logistic distribution, which is symetric about the mean. The alpha parameter primarily affects dispersion (variance), with larger values resulting in values closer to the mean (less variance), and the beta parameter primarily influences the mean. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "logistic-dist", 
            "alpha", 
            "beta", 
            "[", 
            "low", 
            "high", 
            "]"
        ], 
        "declaration": "logistic-dist(alpha, beta [, low, high])", 
        "name": "logistic-dist"
    }, 
    "make-markov": {
        "description": "Generate a sequence of items from a Markov process. The rules parameter has the form: (prev1 prev2 ... prevn - next1 next2 ... nextn) where prev1 through prevn represent a sequence of most recent (past) states. The symbol * is treated specially: it matches any previous state. If prev1 through prevn (which may be just one state as in the example above) match the previously generated states, this rule applies. Note that every rule must specify the same number of previous states; this number is known as the order of the Markov model. The first rule in rules that applies is used to select the next state. If no rule applies, the next state is NIL (which is a valid state that can be used in rules). Assuming a rule applies, the list of possible next states is specified by next1 through nextn. Notice that these are alternative choices for the next state, not a sequence of future states, and each rule can have any number of choices. Each choice may be the state itself (a symbol or a number), or the choice may be a list consisting of the state and a weight. The weight may be given by a pattern, in which case the next item of the pattern is obtained every time the rule is applied. For example, this rules says that if the previous states were A and B, the next state can be A with a weight of 0.5 or C with an implied weight of 1: (A B - (A 0.5) C). The default length of the period is the length of rules. The past parameter must be provided. It is a list of states whose length matches the order of the Markov model. The keyword parameter produces may be used to map from state symbols or numbers to other values or patterns. The parameter is a list of alternating symbols and values. For example, to map A to 69 and B to 71, use list(quote(a), 69, quote(b), 71). You can also map symbols to patterns, for example list(quote(a), make-cycle({57 69}), quote(b), make-random({59 71})). The next item of the pattern is is generated each time the Markov model generates the corresponding state. Finally, the produces keyword can be eval:, which means to evaluate the Markov model state. This could be useful if states are Nyquist global variables such as C4, CS4, D4, ]..., which evaluate to numerical values (60, 61, 62, ....", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-markov", 
            "rules", 
            "past:", 
            "past", 
            "produces:", 
            "produces", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-markov(rules, past: past, produces: produces, for: for, name: name, trace: trace)", 
        "name": "make-markov"
    }, 
    "progv": {
        "description": "slist - list of symbols, vlist - list of values to bind to the symbols, expr - expression(s) to evaluate, returns - the value of the last expression", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "progv", 
            "slist", 
            "vlist", 
            "expr..."
        ], 
        "declaration": "(progv slist vlist expr...)", 
        "name": "progv"
    }, 
    "score-last-indexof": {
        "description": "Return the index (position) of the last score event (in range) for which applying function using (function time dur expression) returns true.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-last-indexof", 
            "score", 
            "function", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-last-indexof(score, function, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-last-indexof"
    }, 
    "snd-areson": {
        "description": "A notch filter modeled after the areson unit generator in Csound. The snd-areson filter is an exact complement of snd-reson such that if both are applied to the same signal with the same parameters, the sum of the results yeilds the original signal. Note that because of this complementary design, the power is not normalized as in snd-reson. See snd-reson for details on normalization. You should use areson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-areson", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-areson(sound, hz, bw,normalization)", 
        "name": "snd-areson"
    }, 
    "zerop": {
        "description": "expr - the number to test, returns - t if the number is zero, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "zerop", 
            "expr"
        ], 
        "declaration": "zerop(expr)", 
        "name": "zerop"
    }, 
    "listp": {
        "description": "expr - the expression to check, returns - t if the value is a cons or nil, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "listp", 
            "expr"
        ], 
        "declaration": "listp(expr)", 
        "name": "listp"
    }, 
    "clarinet-all": {
        "description": "A variation of clarinet-freq that includes controls vibrato-freq (a FLONUM for vibrato frequency in Hertz), vibrato-gain (a FLONUM for the amount of amplitude vibrato), reed-stiffness (a FLONUM or SOUND controlling reed stiffness in the clarinet model), and noise (a FLONUM or SOUND controlling noise amplitude in the input air pressure). The vibrato-gain is a number from zero to one, where zero indicates no vibrato, and one indicates a plus/minus 50% change in breath envelope values. Similarly, the noise parameter ranges from zero to one where zero means no noise and one means white noise with a peak amplitude of plus/minus 40% of the breath-env. The reed-stiffness parameter varies from zero to one. The duration of the resulting sound is the minimum duration of breath-env, freq-env, reed-stiffness, and noise. As with clarinet-freq, these parameters may be either FLONUMs or SOUNDs, and FLONUMs are coerced to sounds with a nominal duration of 30.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "clarinet-all", 
            "step", 
            "breath-env", 
            "freq-env", 
            "vibrato-freq", 
            "vibrato-gain", 
            "reed-stiffness", 
            "noise"
        ], 
        "declaration": "clarinet-all(step, breath-env, freq-env, vibrato-freq, vibrato-gain, reed-stiffness, noise)", 
        "name": "clarinet-all"
    }, 
    "s-read-reverse": {
        "description": "This function is identical to s-read (see \"Sound File Input and Output\"), except it reads the indicated samples in reverse. Like s-reverse (see above), it uses XLISP in the inner loop, so it is slow. Unlike s-reverse, s-read-reverse uses a fixed amount of memory that is independent of how many samples are computed. Multiple channels are handled.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-read-reverse", 
            "filename", 
            "time-offset:", 
            "offset", 
            "srate:", 
            "sr", 
            "dur:", 
            "dur", 
            "nchans:", 
            "chans", 
            "format:", 
            "format", 
            "mode:", 
            "mode", 
            "bits:", 
            "n", 
            "swap:", 
            "flag"
        ], 
        "declaration": "s-read-reverse(filename, time-offset: offset, srate: sr, dur: dur, nchans: chans, format: format, mode: mode, bits: n, swap: flag)", 
        "name": "s-read-reverse"
    }, 
    "snd-reson": {
        "description": "A second-order resonating (bandpass) filter with center frequency hz and bandwidth bw, modeled after the reson unit generator in Csound. The normalization parameter must be an integer and (like in Csound) specifies a scaling factor. A value of 1 specifies a peak amplitude response of 1.0; all frequencies other than hz are attenuated. A value of 2 specifies the overall RMS value of the amplitude response is 1.0; thus filtered white noise would retain the same power. A value of zero specifies no scaling. The result sample rate, start time, etc. are takend from sound. You should use reson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-reson", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-reson(sound, hz, bw, normalization)", 
        "name": "snd-reson"
    }, 
    "progn": {
        "description": "expr - the expressions to evaluate, returns - the value of the last expression (or nil)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "progn", 
            "expr..."
        ], 
        "declaration": "progn(expr...)", 
        "name": "progn"
    }, 
    "expt": {
        "description": "x-expr - the floating point number, y-expr - the floating point exponent, returns - x to the y power", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "expt", 
            "x-expr", 
            "y-expr"
        ], 
        "declaration": "expt(x-expr, y-expr)", 
        "name": "expt"
    }, 
    "snd-flute-freq": {
        "description": "A flute model just like snd-flute but with an additional parameter for continuous frequency control. You should use flute-freq instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-flute-freq", 
            "freq", 
            "breath-env", 
            "freq-env", 
            "sr"
        ], 
        "declaration": "snd-flute-freq(freq, breath-env,freq-env, sr)", 
        "name": "snd-flute-freq"
    }, 
    "tagbody": {
        "description": "expr - expression(s) to evaluate or tags (symbols), returns - nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "tagbody", 
            "expr..."
        ], 
        "declaration": "tagbody(expr...)", 
        "name": "tagbody"
    }, 
    "snd-sax-freq": {
        "description": "A sax model just like snd-sax but with an additional parameter for continuous frequency control. You should use sax-freq instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sax-freq", 
            "freq", 
            "freq-env", 
            "breath-env", 
            "sr"
        ], 
        "declaration": "snd-sax-freq(freq, freq-env, breath-env, sr)", 
        "name": "snd-sax-freq"
    }, 
    "1+": {
        "description": "expr - the number, returns - the number plus one", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "1+", 
            "expr"
        ], 
        "declaration": "(1+ expr)", 
        "name": "1+"
    }, 
    "1-": {
        "description": "expr - the number, returns - the number minus one", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "1-", 
            "expr"
        ], 
        "declaration": "(1- expr)", 
        "name": "1-"
    }, 
    "snd-read": {
        "description": "Loads a sound from a file with name filename. Files are assumed to consist of a header followed by frames consisting of one sample from each channel. The format specifies the type of header, but this information is currently ignored. Nyquist looks for a number of header formats and automatically figures out which format to read. If a header can be identified, the header is first read from the file. Then, the file pointer is advanced by the indicated offset (in seconds). If there is an unrecognized header, Nyquist will assume the file has no header. If the header size is a multiple of the frame size (bytes/sample * number-of-channels), you can use offset to skip over the header. To skip N bytes, use an offset of: (/ (float N) sr (/ bits 8) channels) If the header is not a multiple of the frame size, either write a header or contact the author (dannenberg@cs.cmu.edu) for assistance. Nyquist will round offset to the nearest sample. The resulting sound will start at time t0. If a header is found, the file will be interpreted according to the header information. If no header was found, channels tells how many channels there are, the samples are encoded according to mode, the sample length is bits, and sr is the sample rate. The swap flag is 0 or 1, where 1 means to swap sample bytes. The duration to be read (in seconds) is given by dur. If dur is longer than the data in the file, then a shorter duration will be returned. If the file contains one channel, a sound is returned. If the file contains 2 or more channels, an array of sounds is returned. Note: you probably want to call s-read (see Section \"Sound File Input and Output\") instead of snd-read. Also, see Section \"Sound File Input and Output\" for information on the mode and format parameters.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-read", 
            "filename", 
            "offset", 
            "t0", 
            "format", 
            "channels", 
            "mode", 
            "bits", 
            "swap", 
            "sr", 
            "dur"
        ], 
        "declaration": "snd-read(filename, offset, t0, format,channels, mode, bits, swap, sr,dur)", 
        "name": "snd-read"
    }, 
    "pwlvr": {
        "description": "Creates a piece-wise linear envelope with breakpoints at (0, l1), (t2, l2), etc., ending with (tn, ln, where tj is the sum of i2 through ij. In other words, the breakpoint times are specified in terms of intervals rather than cummulative time. Otherwise, the behavior is like that of pwlv.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwlvr", 
            "l1", 
            "i2", 
            "l2", 
            "i3", 
            "i3", 
            "...", 
            "in", 
            "ln"
        ], 
        "declaration": "pwlvr(l1, i2, l2, i3, i3, ... in, ln)", 
        "name": "pwlvr"
    }, 
    "clip": {
        "description": "Hard limit sound to the given peak, a positive number. The samples of sound are constrained between an upper value of peak and a lower value of -peak. If sound is a number, clip will return sound limited by peak. If sound is a multichannel sound, clip returns a multichannel sound where each channel is clipped. The result has the type, sample rate, starting time, etc. of sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "clip", 
            "sound", 
            "peak"
        ], 
        "declaration": "clip(sound, peak)", 
        "name": "clip"
    }, 
    "make-array": {
        "description": "size - the size of the new array (integer), returns - the new array", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-array", 
            "size"
        ], 
        "declaration": "make-array(size)", 
        "name": "make-array"
    }, 
    "snd-resample": {
        "description": "Resample sound f using high-quality interpolation, yielding a new sound with the specified rate. The result is scaled by 0.95 because often, in resampling, interpolated values exceed the original sample values, and this could lead to clipping. The resulting start time, etc. are taken from f. Use resample instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-resample", 
            "f", 
            "rate"
        ], 
        "declaration": "snd-resample(f,rate)", 
        "name": "snd-resample"
    }, 
    "pwe-list": {
        "description": "A version of pwe that takes a single list of breakpoints as its argument. See pwl-list above for the rationale.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwe-list", 
            "breakpoints"
        ], 
        "declaration": "pwe-list(breakpoints)", 
        "name": "pwe-list"
    }, 
    "sax": {
        "description": "A physical model of a sax from STK. The step parameter is a FLONUM that controls the tube length, and the breath-env controls the air pressure and also determines the length of the resulting sound. The breath-env signal should range from zero to one.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sax", 
            "step", 
            "breath-env"
        ], 
        "declaration": "sax(step, breath-env)", 
        "name": "sax"
    }, 
    "top-level": {
        "description": "returns - never returns", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "top-level"
        ], 
        "declaration": "(top-level)", 
        "name": "top-level"
    }, 
    "transpose-abs": {
        "description": "Evaluates beh with *transpose* set to amount. The effect is the transposition of the nominal pitches in beh (under the default global environment) by amount.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "transpose-abs", 
            "amount", 
            "beh"
        ], 
        "declaration": "transpose-abs(amount, beh)", 
        "name": "transpose-abs"
    }, 
    "snd-partial": {
        "description": "This is a special case of snd-amosc that generates a sinusoid starting at phase 0 degrees. The env parameter gives the envelope or any other amplitude modulation. You should use partial instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-partial", 
            "sr", 
            "hz", 
            "t0", 
            "env"
        ], 
        "declaration": "snd-partial(sr, hz, t0, env)", 
        "name": "snd-partial"
    }, 
    "markov-create-rules": {
        "description": "Generate a set of rules suitable for the make-markov function. The sequence is a \"typical\" sequence of states, and order is the order of the Markov model. It is often the case that a sample sequence will not have a transition from the last state to any other state, so the generated Markov model can reach a \"dead end\" where no rule applies. This might lead to an infinite stream of NIL's. To avoid this, the optional parameter generalize can be set to t (true), indicating that there should be a fallback rule that matches any previous states and whose future states are weighted according to their frequency in sequence. For example, if sequence contains 5 A's, 5 B's and 10 G's, the default rule will be (* - (A 5) (B 5) (G 10)). This rule will be appended to the end so it will only apply if no other rule does.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "markov-create-rules", 
            "sequence", 
            "order", 
            "[", 
            "generalize", 
            "]"
        ], 
        "declaration": "markov-create-rules(sequence, order [, generalize])", 
        "name": "markov-create-rules"
    }, 
    "min": {
        "description": "expr - the expressions to be checked, returns - the smallest number in the list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "min", 
            "expr..."
        ], 
        "declaration": "min(expr...)", 
        "name": "min"
    }, 
    "-": {
        "description": "expr - the numbers, returns - the result of the subtraction", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "-", 
            "expr..."
        ], 
        "declaration": "(- expr...)", 
        "name": "-"
    }, 
    "snd-resonvc": {
        "description": "This function is identical to snd-reson except hz (center frequency) is a sound. Filter coefficients are updated at the sample rate of hz. You should use reson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-resonvc", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-resonvc(sound, hz, bw,normalization)", 
        "name": "snd-resonvc"
    }, 
    "set-difference": {
        "description": "Compute the set of all elements that are in a but not in b.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "set-difference", 
            "a", 
            "b"
        ], 
        "declaration": "set-difference(a, b)", 
        "name": "set-difference"
    }, 
    "score-sort": {
        "description": "Sort the notes in a score into start-time order. If copy-flag is nil, this is a destructive operation which should only be performed if the top-level score list is a fresh copy that is not shared by any other variables. (The copy-flag is intended for internal system use only.) For the following operations, it is assumed that scores are sorted, and all operations return a sorted score.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-sort", 
            "score", 
            "[", 
            "copy-flag", 
            "]"
        ], 
        "declaration": "score-sort(score [, copy-flag])", 
        "name": "score-sort"
    }, 
    "set-pitch-names": {
        "description": "Initializes pitch variables (c0, cs0, df0, d0, ... b0, c1, ... b7). A440 (the default tuning) is represented by the step 69.0, so the variable a4 (fourth octave A) is set to 69.0. You can change the tuning by setting *A4-Hertz* to a value (in Hertz) and calling set-pitch-names to reinitialize the pitch variables. Note that this will result in non-integer step values. It does not alter the mapping from step values to frequency. There is no built-in provision for stretched scales or non-equal temperament, although users can write or compute any desired fractional step values.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "set-pitch-names"
        ], 
        "declaration": "set-pitch-names()", 
        "name": "set-pitch-names"
    }, 
    "snd-gate": {
        "description": "This function generates an exponential rise and decay intended for noise gate implementation. The decay starts when the signal drops below threshold and stays there for longer than lookahead. Decay continues until the value reaches floor, at which point the decay stops and the output value is held constant. Either during the decay or after the floor is reached, if the signal goes above threshold, then the output value will rise to unity (1.0) at the point the signal crosses the threshold. Again, look-ahead is used, so the rise actually starts before the signal crosses the threshold. The rise is a constant-rate exponential and set so that a rise from floor to unity occurs in risetime. Similarly, the fall is a constant-rate exponential such that a fall from unity to floor takes falltime. The result is delayed by lookahead, so the output is not actually synchronized with the input. To compensate, you should drop the initial lookahead of samples. Thus, snd-gate is not recommended for direct use. Use gate instead (see Section \"Miscellaneous Functions\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-gate", 
            "sound", 
            "lookahead", 
            "risetime", 
            "falltime", 
            "floor", 
            "threshold"
        ], 
        "declaration": "snd-gate(sound, lookahead, risetime, falltime, floor, threshold)", 
        "name": "snd-gate"
    }, 
    "*autonorm-target*": {
        "description": "The target peak amplitude for the autonorm feature. The default value is 0.9. See Sections \"Memory Space and Normalization\" and \"Sound File Input and Output\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*autonorm-target*"
        ], 
        "declaration": "*autonorm-target*", 
        "name": "*autonorm-target*"
    }, 
    "play": {
        "description": "Play the sound through the DAC. Note that play is a command in SAL. In XLISP, it is a function, so the syntax is (play sound), and in SAL, you can call the XLISP function as #play(sound). The play command or function writes a file and plays it. The details of this are system-dependent, but play is defined in the file system.lsp. The variable *default-sf-dir* names a directory into which to save a sound file. Be careful not to call play or sound-play within a function and then invoke that function from another play command.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "play", 
            "sound"
        ], 
        "declaration": "play sound", 
        "name": "play"
    }, 
    "lowpass8": {
        "description": "An eight-pole Butterworth lowpass filter. The cutoff frequency is hz (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lowpass8", 
            "signal", 
            "hz"
        ], 
        "declaration": "lowpass8(signal, hz)", 
        "name": "lowpass8"
    }, 
    "unless": {
        "description": "texpr - the test expression, expr - the expression(s) to be evaluated if texpr is nil, returns - the value of the last expression or nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "unless", 
            "texpr", 
            "expr..."
        ], 
        "declaration": "unless(texpr, expr...)", 
        "name": "unless"
    }, 
    "trace": {
        "description": "sym - the function to add (quoted), returns - the trace list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "trace", 
            "sym"
        ], 
        "declaration": "trace(sym)", 
        "name": "trace"
    }, 
    "lowpass2": {
        "description": "A fixed-parameter, second-order lowpass filter based on snd-biquad. The cutoff frequency is given by hz (a FLONUM) and an optional Q factor is given by q (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lowpass2", 
            "signal", 
            "hz", 
            "[", 
            "q", 
            "]"
        ], 
        "declaration": "lowpass2(signal, hz [, q])", 
        "name": "lowpass2"
    }, 
    "flute": {
        "description": "A physical model of a flute from STK. The step parameter is a FLONUM that controls the tube length, and the breath-env controls the air pressure and also determines the starting time and length of the resulting sound. The breath-env signal should range from zero to one.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "flute", 
            "step", 
            "breath-env"
        ], 
        "declaration": "flute(step, breath-env)", 
        "name": "flute"
    }, 
    "compress": {
        "description": "Compress input using map, a compression curve probably generated by compress-map (see above). Adjustments in gain have the given rise-time and fall-time. Lookahead tells how far ahead to look at the signal, and is rise-time by default.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "compress", 
            "input", 
            "map", 
            "rise-time", 
            "fall-time", 
            "[", 
            "lookahead", 
            "]"
        ], 
        "declaration": "compress(input, map, rise-time, fall-time [, lookahead])", 
        "name": "compress"
    }, 
    "lowpass6": {
        "description": "A six-pole Butterworth lowpass filter. The cutoff frequency is hz (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lowpass6", 
            "signal", 
            "hz"
        ], 
        "declaration": "lowpass6(signal, hz)", 
        "name": "lowpass6"
    }, 
    "db-to-linear": {
        "description": "Returns the conversion of x from decibels to linear. 0dB is converted to 1. 20dB represents a linear factor of 10. If x is a sound, each sample is converted and a sound is returned. If x is a multichannel sound, each channel is converted and a multichannel sound (array) is returned. Note: With sounds, conversion is only performed on actual samples, not on the implicit zeros before the beginning and after the termination of the sound. Sample rates, start times, etc. are taken from x.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "db-to-linear", 
            "x"
        ], 
        "declaration": "db-to-linear(x)", 
        "name": "db-to-linear"
    }, 
    "lowpass4": {
        "description": "A four-pole Butterworth lowpass filter. The cutoff frequency is hz (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lowpass4", 
            "signal", 
            "hz"
        ], 
        "declaration": "lowpass4(signal, hz)", 
        "name": "lowpass4"
    }, 
    "step-to-hz": {
        "description": "Returns a frequency in hz for pitch, a step number or a SOUND type representing a time-varying step number. The result is a FLONUM if pitch is a number, and a SOUND if pitch is a SOUND. See also hz-to-step (above).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "step-to-hz", 
            "pitch"
        ], 
        "declaration": "step-to-hz(pitch)", 
        "name": "step-to-hz"
    }, 
    "snd-aresoncv": {
        "description": "This function is identical to snd-areson except the bw (bandwidth) parameter is a sound. Filter coefficients are updated at the sample rate of bw. The \"cv\" suffix stands for Constant, Variable, indicating that hz and bw are constant (a number) and variable (a sound), respectively. This naming convention is used throughout. You should use areson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-aresoncv", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-aresoncv(sound, hz, bw,normalization)", 
        "name": "snd-aresoncv"
    }, 
    "assoc": {
        "description": "expr - the expression to find, alist - the association list, :test - the test function (defaults to eql), :test-not - the test function (sense inverted) , returns - the alist entry or nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "assoc", 
            "expr", 
            "alist", 
            "test:", 
            "test", 
            "test-not:", 
            "test-not"
        ], 
        "declaration": "assoc(expr, alist, test: test, test-not: test-not)", 
        "name": "assoc"
    }, 
    "current-path": {
        "description": "Returns the full path name of the file that is currently being loaded (see load). Returns NIL if no file is being loaded.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "current-path"
        ], 
        "declaration": "current-path()", 
        "name": "current-path"
    }, 
    "linear-dist": {
        "description": "Return a FLONUM value from a linear distribution, where the probability of a value decreases linearly from zero to g which must be greater than zero. (See Figure 7.) The linear distribution is useful for generating for generating time and pitch intervals.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "linear-dist", 
            "g"
        ], 
        "declaration": "linear-dist(g)", 
        "name": "linear-dist"
    }, 
    "terpri": {
        "description": "stream - the output stream (default is standard output), returns - nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "terpri", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "terpri([stream])", 
        "name": "terpri"
    }, 
    "stereo-chorus": {
        "description": "A chorus effect applied to snd, a SOUND (monophonic). The output is a stereo sound. All parameters are built-in, but see the simple source code to make modifications.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "stereo-chorus", 
            "snd"
        ], 
        "declaration": "stereo-chorus(snd)", 
        "name": "stereo-chorus"
    }, 
    "maketable": {
        "description": "Assumes that the samples in sound constitute one period of a wavetable, and returns a wavetable suitable for use as the table argument to the osc function (see below). Currently, tables are limited to 1,000,000 samples. This limit is the compile-time constant max_table_len set in sound.h.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "maketable", 
            "sound"
        ], 
        "declaration": "maketable(sound)", 
        "name": "maketable"
    }, 
    "exp": {
        "description": "x-expr - the floating point number, returns - e to the x power", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "exp", 
            "x-expr"
        ], 
        "declaration": "exp(x-expr)", 
        "name": "exp"
    }, 
    "setdir": {
        "description": "path - the path of the new directory, verbose - print error message if current directory cannot be changed to path, returns - the resulting full path, e.g. (setdir \".\") gets the current working directory, or nil if an error occurs", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "setdir", 
            "path", 
            "[", 
            "verbose", 
            "]"
        ], 
        "declaration": "setdir(path [, verbose])", 
        "name": "setdir"
    }, 
    "+": {
        "description": "expr - the numbers, returns - the result of the addition", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "+", 
            "expr..."
        ], 
        "declaration": "(+ expr...)", 
        "name": "+"
    }, 
    "find-in-xlisp-path": {
        "description": "filename - the name of the file to search for, returns - a full path name to the first occurrence found", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "find-in-xlisp-path", 
            "filename"
        ], 
        "declaration": "find-in-xlisp-path(filename)", 
        "name": "find-in-xlisp-path"
    }, 
    "score-indexof": {
        "description": "Return the index (position) of the first score event (in range) for which applying function using (function time dur expression) returns true.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-indexof", 
            "score", 
            "function", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-indexof(score, function, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-indexof"
    }, 
    "slope": {
        "description": "Computes the first derivative (slope) of signal. The start time, sample rate, etc. are taken from signal.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "slope", 
            "signal"
        ], 
        "declaration": "slope(signal)", 
        "name": "slope"
    }, 
    "score-play": {
        "description": "Play score using timed-seq to convert the score to a sound, and play to play the sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-play", 
            "score"
        ], 
        "declaration": "score-play(score)", 
        "name": "score-play"
    }, 
    "s-min": {
        "description": "Compute the minimum of two functions, sound1 and sound2. This function also accepts numbers and multichannel sounds and returns the corresponding data type. The start time of the result is the maximum of the start times of sound1 and sound2. The logical stop time and physical stop time of the result is the minimum of the logical stop and physical stop times respectively of sound1 and sound2. Note, therefore, that the result value is zero except within the bounds of both input sounds.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-min", 
            "sound1", 
            "sound2"
        ], 
        "declaration": "s-min(sound1, sound2)", 
        "name": "s-min"
    }, 
    "snd-clarinet-freq": {
        "description": "A clarinet model just like snd-clarinet but with an additional parameter for continuous frequency control. You should use clarinet-freq instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-clarinet-freq", 
            "freq", 
            "breath-env", 
            "freq-env", 
            "sr"
        ], 
        "declaration": "snd-clarinet-freq(freq, breath-env, freq-env, sr)", 
        "name": "snd-clarinet-freq"
    }, 
    "expr-get-attr": {
        "description": "Get the value of the given attribute from a score event expression. If attribute is not present, return default if specified, and otherwise nil.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "expr-get-attr", 
            "expression", 
            "attribute", 
            "[", 
            "default", 
            "]"
        ], 
        "declaration": "expr-get-attr(expression, attribute [, default])", 
        "name": "expr-get-attr"
    }, 
    "at-abs": {
        "description": "Evaluate beh with *warp* shifted so that local time 0 maps to time. In SAL, you can use the infix operator @@ as in beh @@ time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "at-abs", 
            "time", 
            "beh"
        ], 
        "declaration": "at-abs(time, beh)", 
        "name": "at-abs"
    }, 
    "snd-fetch": {
        "description": "Reads samples sequentially from sound. This returns a FLONUM after each call, or NIL when sound terminates. Note: snd-fetch modifies sound; it is strongly recommended to copy sound using snd-copy and access only the copy with snd-fetch.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-fetch", 
            "sound"
        ], 
        "declaration": "snd-fetch(sound)", 
        "name": "snd-fetch"
    }, 
    "snd-save": {
        "description": "Evaluates the expression, which should result in a sound or an array of sounds, and writes the result to the given filename. If a multichannel sound (array) is written, the channels are up-sampled to the highest rate in any channel so that all channels have the same sample rate. The maximum number of samples written per channel is given by maxlen, which allows writing the initial part of a very long or infinite sound. A header is written according to format, samples are encoded according to mode, using bits bits/sample, and swapping bytes if swap is 1 (otherwise it should be 0). If play is not null, the audio is played in real time (to the extent possible) as it is computed. The peak value of the sound is returned. In addition, the symbol *RSLT* is bound to a list containing the sample rate, number of channels, and duration (in that order) of the saved sound. Note: you probably want to call s-save (see Section \"Sound File Input and Output\") instead. The format and mode parameters are described in Section \"Sound File Input and Output\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-save", 
            "expression", 
            "maxlen", 
            "filename", 
            "format", 
            "mode", 
            "bits", 
            "swap", 
            "play"
        ], 
        "declaration": "snd-save(expression, maxlen,filename, format, mode, bits, swap, play)", 
        "name": "snd-save"
    }, 
    "cdr": {
        "description": "expr - the list node, returns - the cdr of the list node", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cdr", 
            "expr"
        ], 
        "declaration": "cdr(expr)", 
        "name": "cdr"
    }, 
    "macroexpand": {
        "description": "form - the form to expand, returns - the macro expansion", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "macroexpand", 
            "form"
        ], 
        "declaration": "macroexpand(form)", 
        "name": "macroexpand"
    }, 
    "write-int": {
        "description": "ch - the character to write, stream - the output stream (default is standard output), length - the length of the integer in bytes (default is 4), returns - the integer, Note: Integers are assumed to be big-endian (high-order byte first) and signed, regardless of the platform. To write in little-endian format, use a negative number for the length, e.g. -4 indicates a 4-bytes, low-order byte first. The file should be opened in binary mode.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "write-int", 
            "ch", 
            "[", 
            "stream", 
            "[", 
            "length", 
            "]", 
            "]"
        ], 
        "declaration": "write-int(ch [, stream [, length]])", 
        "name": "write-int"
    }, 
    "char-int": {
        "description": "chr - the character, returns - the ascii character code", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "char-int", 
            "chr"
        ], 
        "declaration": "char-int(chr)", 
        "name": "char-int"
    }, 
    "play-file": {
        "description": "Play the contents of a sound file named by filename. The s-read function is used to read the file, and unless filename specifies an absolute path or starts with \".\", it will be read from *default-sf-dir*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "play-file", 
            "filename"
        ], 
        "declaration": "play-file(filename)", 
        "name": "play-file"
    }, 
    "snd-congen": {
        "description": "A simple \"contour generator\" based on analog synthesizers. The gate is a sound that normally steps from 0.0 to 1.0 at the start of an envelop and goes from 1.0 back to 0.0 at the beginning of the release. At each sample, the output converges to the input exponentially. If gate is greater than the output, e.g. the attack, then the output converges half-way to the output in risetime. If the gate is less than the output, the half-time is falltime. The sample rate, starting time, logical-stop-time, and terminate time are taken from gate. You should use congen instead (see Section \"Filter Behaviors\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-congen", 
            "gate", 
            "risetime", 
            "falltime"
        ], 
        "declaration": "snd-congen(gate, risetime, falltime)", 
        "name": "snd-congen"
    }, 
    "tapv": {
        "description": "A delay line with a variable position tap. Identical to snd-tapv. See it for details (\"Signal Operations\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "tapv", 
            "sound", 
            "offset", 
            "vardelay", 
            "maxdelay"
        ], 
        "declaration": "tapv(sound, offset, vardelay, maxdelay)", 
        "name": "tapv"
    }, 
    "read-float": {
        "description": "stream - the input stream (default is standard input), length - the length of the float in bytes (default is 4, legal values are -4, -8, 4, and 8), returns - the integer, Note: Floats are assumed to be big-endian (high-order byte first) and signed, regardless of the platform. To read little-endian format, use a negative number for the length, e.g. -4 indicates a 4-bytes, low-order byte first. The file should be opened in binary mode.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "read-float", 
            "[", 
            "stream", 
            "[", 
            "length", 
            "]", 
            "]"
        ], 
        "declaration": "read-float([stream [, length]])", 
        "name": "read-float"
    }, 
    "snd-siosc": {
        "description": "A Spectral Interpolation Oscillator with frequency modulation. The tables is a list of sounds and sample counts as follows: (table0 count1 table1 ... countN tableN). The initial waveform is given by table0, which is interpolated linearly to table1 over the first count1 samples. From count1 to count2 samples, the waveform is interpolated from table1 to table2, and so on. If more than countN samples are generated, tableN is used for the remainder of the sound. The duration and logical stop time of the sound is taken from fm, which specified frequency modulation (deviation) in Hertz. You should use siosc instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-siosc", 
            "tables", 
            "sr", 
            "hz", 
            "t0", 
            "fm"
        ], 
        "declaration": "snd-siosc(tables, sr, hz, t0,fm)", 
        "name": "snd-siosc"
    }, 
    "abs": {
        "description": "expr - the number, returns - the absolute value of the number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "abs", 
            "expr"
        ], 
        "declaration": "abs(expr)", 
        "name": "abs"
    }, 
    "integrate": {
        "description": "Computes the integral of signal. The start time, sample rate, etc. are taken from signal.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "integrate", 
            "signal"
        ], 
        "declaration": "integrate(signal)", 
        "name": "integrate"
    }, 
    "decf": {
        "description": "Decrement symbol by one. (See incf, above.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "decf", 
            "symbol"
        ], 
        "declaration": "decf(symbol)", 
        "name": "decf"
    }, 
    "first": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "first", 
            "expr"
        ], 
        "declaration": "first(expr)", 
        "name": "first"
    }, 
    "sax-all": {
        "description": "A variation of sax-freq that includes controls vibrato-freq (a FLONUM for vibrato frequency in Hertz), vibrato-gain (a FLONUM for the amount of amplitude vibrato), reed-stiffness (a SOUND controlling reed stiffness in the sax model), noise (a SOUND controlling noise amplitude in the input air pressure), blow-pos (a SOUND controlling the point of excitation of the air column), and reed-table-offset (a SOUND controlling a parameter of the reed model). The vibrato-gain is a number from zero to one, where zero indicates no vibrato, and one indicates a plus/minus 50% change in breath envelope values. Similarly, the noise parameter ranges from zero to one where zero means no noise and one means white noise with a peak amplitude of plus/minus 40% of the breath-env. The reed-stiffness, blow-pos, and reed-table-offset parameters all vary from zero to one. The duration of the resulting sound is the minimum duration of breath-env, freq-env, reed-stiffness, noise, breath-env, blow-pos, and reed-table-offset. As with sax-freq, these parameters may be either FLONUMs or SOUNDs, and FLONUMs are coerced to sounds with a nominal duration of 30.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sax-all", 
            "step", 
            "breath-env", 
            "freq-env", 
            "vibrato-freq", 
            "vibrato-gain", 
            "reed-stiffness", 
            "noise", 
            "blow-pos", 
            "reed-table-offset"
        ], 
        "declaration": "sax-all(step, breath-env, freq-env, vibrato-freq, vibrato-gain, reed-stiffness, noise, blow-pos, reed-table-offset)", 
        "name": "sax-all"
    }, 
    "fboundp": {
        "description": "sym - the symbol, returns - t if a functional value is bound to the symbol, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "fboundp", 
            "sym"
        ], 
        "declaration": "fboundp(sym)", 
        "name": "fboundp"
    }, 
    "get": {
        "description": "sym - the symbol, prop - the property symbol, returns - the property value or nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get", 
            "sym", 
            "prop"
        ], 
        "declaration": "get(sym, prop)", 
        "name": "get"
    }, 
    "macroexpand-1": {
        "description": "form - the macro call form, returns - the macro expansion", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "macroexpand-1", 
            "form"
        ], 
        "declaration": "macroexpand-1(form)", 
        "name": "macroexpand-1"
    }, 
    "nconc": {
        "description": "list - lists to concatenate, returns - the result of concatenating the lists", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "nconc", 
            "list..."
        ], 
        "declaration": "nconc(list...)", 
        "name": "nconc"
    }, 
    "pl-pan2d": {
        "description": "Comparable to Nyquist's existing pan function, pl-pan2d provides not only left-to-right panning, but front-to-back panning as well. The function accepts three parameters: snd is the (monophonic) input SOUND, x is a left-to-right position, and y is a front-to-back position. Both position parameters may be numbers or SOUNDs. An x value of 0 means left, and 1 means right. Intermediate values map linearly between these extremes. Similarly, a y value of 0 causes the sound to play entirely through the front speakers(s), while 1 causes it to play entirely through the rear. Intermediate values map linearly. Note that, although there are usually two rear speakers in Pro-Logic systems, they are both driven by the same signal. Therefore any sound that is panned totally to the rear will be played over both rear speakers. For example, it is not possible to play a sound exclusively through the rear left speaker.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pl-pan2d", 
            "snd", 
            "x", 
            "y"
        ], 
        "declaration": "pl-pan2d(snd, x, y)", 
        "name": "pl-pan2d"
    }, 
    "logior": {
        "description": "expr - the numbers, returns - the result of the inclusive or operation", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "logior", 
            "expr..."
        ], 
        "declaration": "logior(expr...)", 
        "name": "logior"
    }, 
    "snd-atone": {
        "description": "A high-pass filter modeled after the atone unit generator in Csound. The snd-atone filter is an exact complement of snd-tone such that if both are applied to the same signal with the same parameters, the sum of the results yeilds the original signal. You should use hp instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-atone", 
            "sound", 
            "hz"
        ], 
        "declaration": "snd-atone(sound, hz)", 
        "name": "snd-atone"
    }, 
    "flute-freq": {
        "description": "A variation of flute that includes a variable frequency control, freq-env, which specifies frequency deviation in Hz. The duration of the resulting sound is the minimum duration of breath-env and freq-env. These parameters may be of type FLONUM or SOUND. FLONUMs are coerced into SOUNDs with a nominal duration arbitrary set to 30.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "flute-freq", 
            "step", 
            "breath-env", 
            "freq-env"
        ], 
        "declaration": "flute-freq(step, breath-env, freq-env)", 
        "name": "flute-freq"
    }, 
    "upper-case-p": {
        "description": "chr - the character, returns - t if the character is upper case, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "upper-case-p", 
            "chr"
        ], 
        "declaration": "upper-case-p(chr)", 
        "name": "upper-case-p"
    }, 
    "snd-resoncv": {
        "description": "This function is identical to snd-reson except bw (bandwidth) is a sound. Filter coefficients are updated at the sample rate of bw. You should use reson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-resoncv", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-resoncv(sound, hz, bw,normalization)", 
        "name": "snd-resoncv"
    }, 
    "make-length": {
        "description": "Make a pattern of class length-class that regroups items generated by a pattern according to pattern lengths given by length-pattern. Note that length-pattern is not optional: There is no default pattern length and no for: keyword.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-length", 
            "pattern", 
            "length-pattern", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-length(pattern, length-pattern, name: name, trace: trace)", 
        "name": "make-length"
    }, 
    "snd-sitar": {
        "description": "A sitar model implemented in STK. The parameter t0 is the starting time, freq is a FLONUM (in Hz), E dur sets the duration and sr is the sample rate (in Hz) of the resulting sound. You should use sitar instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sitar", 
            "t0", 
            "freq", 
            "dur", 
            "sr"
        ], 
        "declaration": "snd-sitar(t0,freq, dur, sr)", 
        "name": "snd-sitar"
    }, 
    "get-output-stream-string": {
        "description": "stream - the output stream, returns - the output so far as a string, Note: the output stream is emptied by this function", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-output-stream-string", 
            "stream"
        ], 
        "declaration": "get-output-stream-string(stream)", 
        "name": "get-output-stream-string"
    }, 
    "snd-alpasscv": {
        "description": "An all-pass filter with variable feedback. This is just like snd-alpass except feedback is a sound. You should use alpass instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-alpasscv", 
            "sound", 
            "delay", 
            "feedback"
        ], 
        "declaration": "snd-alpasscv(sound, delay,feedback)", 
        "name": "snd-alpasscv"
    }, 
    "s-read": {
        "description": "Reads a sound from filename. The global *default-sf-dir* applies. If a header is detected, the header is used to determine the format of the file, and header information overrides format information provided by keywords (except for time-offset: and dur:). s-read(\"mysound.snd\", srate: 44100) specifies a sample rate of 44100 hz, but if the file has a header specifying 22050 hz, the resulting sample rate will be 22050. The parameters are: offset - the amount of time (in seconds) to skip from the beginning of the file. The default is 0.0. sr - the sample rate of the samples in the file. Default is *default-sf-srate* , which is normally 44100. dur - the maximum duration in seconds to read. Default is 10000. chans - the number of channels to read. It is assumed that samples from each channel are interleaved. Default is 1. format - the header format. See s-save for details. Default is *default-sf-format*, although this parameter is currently ignored. mode - the sample representation, e.g. PCM or float. See s-save for details. Default is *default-sf-format*. n - the number of bits per sample. See s-save for details. Default is *default-sf-bits*. flag - (T or NIL) swap byte order of each sample. Default is NIL. If there is an error, for example if offset is greater than the length of the file, then NIL is returned rather than a sound. Information about the sound is also returned by s-read through *rslt* (Footnote 2) . The list assigned to *rslt* is of the form: (format channels mode bits samplerate duration flags byte-offset), which are defined as follows: format - the header format. See s-save for details. channels - the number of channels. mode - the sample representation, e.g. PCM or float. See s-save for details. bits - the number of bits per sample. samplerate - the sample rate, expressed as a FLONUM. duration - the duration of the sound, in seconds. flags - The values for format, channels, mode, bits, samplerate, and duration are initially just the values passed in as parameters or default values to s-read. If a value is actually read from the sound file header, a flag is set. The flags are: snd-head-format, snd-head-channels, snd-head-mode, snd-head-bits, snd-head-srate, and snd-head-dur. For example, (let ((flags (caddr (cddddr *rslt*)))) (not (zerop (logand flags snd-head-srate)))) tells whether the sample rate was specified in the file. See also sf-info below. byte-offset - the byte offset into the file of the first sample to be read (this is used by the s-overwrite and s-add-to functions).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-read", 
            "filename", 
            "time-offset:", 
            "offset", 
            "srate:", 
            "sr", 
            "dur:", 
            "dur", 
            "nchans:", 
            "chans", 
            "format:", 
            "format", 
            "mode:", 
            "mode", 
            "bits:", 
            "n", 
            "swap:", 
            "flag"
        ], 
        "declaration": "s-read(filename, time-offset: offset, srate: sr, dur: dur, nchans: chans, format: format, mode: mode, bits: n, swap: flag)", 
        "name": "s-read"
    }, 
    "snd-exp": {
        "description": "Compute the exponential of each sample of sound. Use s-exp instead (see Section \"More Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-exp", 
            "sound"
        ], 
        "declaration": "snd-exp(sound)", 
        "name": "snd-exp"
    }, 
    "bowed-freq": {
        "description": "A variation of bowed that includes a variable frequency control, freq-env, which specifies frequency deviation in Hz. The duration of the resulting sound is the minimum duration of bowpress-env and freq-env. These parameters may be of type FLONUM or SOUND. FLONUMs are coerced into SOUNDs with a nominal duration arbitrarily set to 30s.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "bowed-freq", 
            "step", 
            "bowpress-env", 
            "freq-env"
        ], 
        "declaration": "bowed-freq(step, bowpress-env, freq-env)", 
        "name": "bowed-freq"
    }, 
    "event-set-dur": {
        "description": "Construct a new event where the duration (or stretch factor) of event is replaced by dur.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-set-dur", 
            "event", 
            "dur"
        ], 
        "declaration": "event-set-dur(event, dur)", 
        "name": "event-set-dur"
    }, 
    "remove": {
        "description": "expr - the element to remove, list - the list, :test - the test function (defaults to eql), :test-not - the test function (sense inverted) , returns - copy of list with matching expressions removed", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "remove", 
            "expr", 
            "list", 
            "test:", 
            "test", 
            "test-not:", 
            "test-not"
        ], 
        "declaration": "remove(expr, list, test: test, test-not: test-not)", 
        "name": "remove"
    }, 
    "subseq": {
        "description": "string - the string, start - the starting position (zero origin), end - the ending position + 1 (defaults to end), returns - substring between start and end", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "subseq", 
            "string", 
            "start", 
            "[", 
            "end", 
            "]"
        ], 
        "declaration": "subseq(string, start [, end])", 
        "name": "subseq"
    }, 
    "symbolp": {
        "description": "expr - the expression to check, returns - t if the expression is a symbol, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "symbolp", 
            "expr"
        ], 
        "declaration": "symbolp(expr)", 
        "name": "symbolp"
    }, 
    "convolve": {
        "description": "Convolves two signals. The first can be any length, but the computation time per sample and the total space required are proportional to the length of response. The start time, logical stop time, and sample rate of the output match those of the input sound. The physical stop time of the result is the physical stop time of sound plus the duration of the response so that the result sound includes the \"tail\" of the filter response. The response is assumed to have the same sample rate as sound. The samples are used as is without resampling.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "convolve", 
            "sound", 
            "response"
        ], 
        "declaration": "convolve(sound,response)", 
        "name": "convolve"
    }, 
    "s-plot": {
        "description": "Plots sound in a window. This function was designed to run a plot program on a Unix workstation, but now is primarily used with NyquistIDE, which has self-contained plotting. Normally, time/value pairs in ascii are written to points.dat and system-dependent code (or the NyquistIDE program) takes it from there. If the sound is longer than the optional dur (default is 2 seconds), only the first dur seconds are plotted. If there are more than n samples to be plotted, the signal is interpolated to have n samples before plotting. The data file used is *default-plot-file*:", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-plot", 
            "sound", 
            "[", 
            "dur", 
            "n", 
            "]"
        ], 
        "declaration": "s-plot(sound  [, dur, n])", 
        "name": "s-plot"
    }, 
    "score-sustain": {
        "description": "For each note in the score and in any indicated range, multiply the duration (stretch factor) by amount. This can be used to make notes sound more legato or staccato, and does not change their starting times. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-sustain", 
            "score", 
            "factor", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-sustain(score, factor, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-sustain"
    }, 
    "LOCAL-to-global": {
        "description": "Converts a score (local) time to a real (global) time according to the current environment.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "LOCAL-to-global", 
            "local-time"
        ], 
        "declaration": "LOCAL-to-global(local-time)", 
        "name": "LOCAL-to-global"
    }, 
    "snd-sine": {
        "description": "This is a special case of snd-osc that always generates a sinusoid with initial phase of 0 degrees. You should use sine instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sine", 
            "t0", 
            "hz", 
            "sr", 
            "d"
        ], 
        "declaration": "snd-sine(t0, hz, sr, d)", 
        "name": "snd-sine"
    }, 
    "rrandom": {
        "description": "returns - a random floating point number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "rrandom"
        ], 
        "declaration": "rrandom()", 
        "name": "rrandom"
    }, 
    "rms": {
        "description": "Computes the RMS of sound using a square window of size window-size. The result has a sample rate of rate. The default value of rate is 100 Hz, and the default window size is 1/rate seconds (converted to samples). The rate is a FLONUM and window-size is a FIXNUM.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "rms", 
            "sound", 
            "[", 
            "rate", 
            "window-size", 
            "]"
        ], 
        "declaration": "rms(sound [, rate, window-size])", 
        "name": "rms"
    }, 
    "set": {
        "description": "sym - the symbol being set, expr - the new value, returns - the new value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "set", 
            "sym", 
            "expr"
        ], 
        "declaration": "set(sym, expr)", 
        "name": "set"
    }, 
    "biquad-m": {
        "description": "A fixed-parameter biquad filter with Matlab sign conventions for a0, a1, and a2. All filter coefficients are FLONUMs.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "biquad-m", 
            "signal", 
            "b0", 
            "b1", 
            "b2", 
            "a0", 
            "a1", 
            "a2"
        ], 
        "declaration": "biquad-m(signal, b0, b1, b2, a0, a1, a2)", 
        "name": "biquad-m"
    }, 
    "seq": {
        "description": "Evaluates the first behavior beh1 according to *time* and each successive behavior at the logical-stop time of the previous one. The results are summed to form a sound whose logical-stop is the logical-stop of the last behavior in the sequence. Each behavior can result in a multichannel sound, in which case, the logical stop time is considered to be the maximum logical stop time of any channel. The number of channels in the result is the number of channels of the first behavior. If other behaviors return fewer channels, new channels are created containing constant zero signals until the required number of channels is obtained. If other behaviors return a simple sound rather than multichannel sounds, the sound is automatically assigned to the first channel of a multichannel sound that is then filled out with zero signals. If another behavior returns more channels than the first behavior, the error is reported and the computation is stopped. Sample rates are converted up or down to match the sample rate of the first sound in a sequence.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "seq", 
            "beh1", 
            "[", 
            "beh2", 
            "...", 
            "]"
        ], 
        "declaration": "seq(beh1 [, beh2, ...])", 
        "name": "seq"
    }, 
    "snd-add": {
        "description": "Adds two sounds. The resulting start time is the minimum of the two parameter start times, the logical stop time is the maximum of the two parameter stop times, and the sample rate is the maximum of the two parameter sample rates. Use sim or sum instead of snd-add (see Section \"Combination and Time Structure\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-add", 
            "sound1", 
            "sound"
        ], 
        "declaration": "snd-add(sound1, sound)", 
        "name": "snd-add"
    }, 
    "strcat": {
        "description": "expr - the strings to concatenate, returns - the result of concatenating the strings", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "strcat", 
            "expr..."
        ], 
        "declaration": "strcat(expr...)", 
        "name": "strcat"
    }, 
    "event-has-attr": {
        "description": "Test whether a given score event's expression has the given attribute.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-has-attr", 
            "event", 
            "attribute"
        ], 
        "declaration": "event-has-attr(event, attribute)", 
        "name": "event-has-attr"
    }, 
    "maplist": {
        "description": "fcn - the function or function name, listn - a list for each argument of the function, returns - a list of the values returned", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "maplist", 
            "fcn", 
            "list1", 
            "list..."
        ], 
        "declaration": "maplist(fcn, list1, list...)", 
        "name": "maplist"
    }, 
    "get-output-stream-list": {
        "description": "stream - the output stream, returns - the output so far as a list, Note: the output stream is emptied by this function", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-output-stream-list", 
            "stream"
        ], 
        "declaration": "get-output-stream-list(stream)", 
        "name": "get-output-stream-list"
    }, 
    "boundp": {
        "description": "sym - the symbol, returns - t if a value is bound to the symbol, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "boundp", 
            "sym"
        ], 
        "declaration": "boundp(sym)", 
        "name": "boundp"
    }, 
    "score-get-begin": {
        "description": "Return the begin time of the score.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-get-begin", 
            "score"
        ], 
        "declaration": "score-get-begin(score)", 
        "name": "score-get-begin"
    }, 
    "close": {
        "description": "stream - the stream, returns - nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "close", 
            "stream"
        ], 
        "declaration": "close(stream)", 
        "name": "close"
    }, 
    "clarinet": {
        "description": "A physical model of a clarinet from STK. The step parameter is a FLONUM that controls the tube length, and the breath-env (a SOUND) controls the air pressure and also determines the length of the resulting sound. The breath-env signal should range from zero to one.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "clarinet", 
            "step", 
            "breath-env"
        ], 
        "declaration": "clarinet(step, breath-env)", 
        "name": "clarinet"
    }, 
    "lpc-frame-err": {
        "description": "Get the square root of RMS1/RMS2 from a frame.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lpc-frame-err", 
            "frame"
        ], 
        "declaration": "lpc-frame-err(frame)", 
        "name": "lpc-frame-err"
    }, 
    "phaser": {
        "description": "A phaser effect applied to snd (a SOUND). There are no parameters, but feel free to modify the source code of this one-liner.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "phaser", 
            "snd"
        ], 
        "declaration": "phaser(snd)", 
        "name": "phaser"
    }, 
    "stats": {
        "description": "Prints the memory usage status. See also the XLISP mem function. Safe for ordinary use. This is the only way to find out how much memory is being used by table-lookup oscillator instances.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "stats"
        ], 
        "declaration": "stats()", 
        "name": "stats"
    }, 
    "sublis": {
        "description": "alist - the association list, expr - the expression in which to do the substitutions, :test - the test function (defaults to eql), :test-not - the test function (sense inverted) , returns - the expression with substitutions", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sublis", 
            "alist", 
            "expr", 
            "test:", 
            "test", 
            "test-not:", 
            "test-not"
        ], 
        "declaration": "sublis(alist, expr, test: test, test-not: test-not)", 
        "name": "sublis"
    }, 
    "snd-maxv": {
        "description": "Compute the maximum of sound1 and sound2 on a sample-by-sample basis. The resulting sound has its start time at the maximum of the input start times and a logical stop at the minimum logical stop of the inputs. The physical stop time is the minimum of the physical stop times of the two sounds. Note that this violates the \"normal\" interpretation that sounds are zero outside their start and stop times. For example, even if sound1 extends beyond sound2 and is greater than zero, the result value in this extension will be zero because it will be after the physical stop time, whereas if we simply treated sound2 as zero in this region and took the maximum, we would get a non-zero result. Use s-max instead (see Section \"More Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-maxv", 
            "sound1", 
            "sound2"
        ], 
        "declaration": "snd-maxv(sound1, sound2)", 
        "name": "snd-maxv"
    }, 
    "snd-clip": {
        "description": "Hard limit sound to the given peak, a positive number. The samples of sound are constrained between an upper value of peak and a lower value of -peak. Use clip instead (see Section \"More Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-clip", 
            "sound", 
            "peak"
        ], 
        "declaration": "snd-clip(sound, peak)", 
        "name": "snd-clip"
    }, 
    "piano-note-2": {
        "description": "Similar to piano-note except the duration is nominally 1.0.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "piano-note-2", 
            "step", 
            "dynamic"
        ], 
        "declaration": "piano-note-2(step, dynamic)", 
        "name": "piano-note-2"
    }, 
    "*default-sf-dir*": {
        "description": "The default sound file directory. Unless you give a full path for a file, audio files are assumed to be in this directory. (Applies to many functions that deal with sound files. Check the function description to see if *default-sf-dir* applies.)", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*default-sf-dir*"
        ], 
        "declaration": "*default-sf-dir*", 
        "name": "*default-sf-dir*"
    }, 
    "endp": {
        "description": "list - the list, returns - t if the value is nil, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "endp", 
            "list"
        ], 
        "declaration": "endp(list)", 
        "name": "endp"
    }, 
    "psetq": {
        "description": "sym - the symbol being set (quoted), expr - the new value, returns - the new value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "psetq", 
            "[", 
            "sym", 
            "expr", 
            "]", 
            "..."
        ], 
        "declaration": "psetq([sym, expr]...)", 
        "name": "psetq"
    }, 
    "do": {
        "description": "binding - the variable bindings each of which is either:, 1) a symbol (which is initialized to nil), 2) a list of the form: (sym init [step]) where: sym - is the symbol to bind, init - is the initial value of the symbol, step - is a step expression, texpr - the termination test expression, rexpr - result expressions (the default is nil), expr - the body of the loop (treated like an implicit prog), returns - the value of the last result expression", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "do", 
            "binding...", 
            "texpr", 
            "rexpr...", 
            "expr..."
        ], 
        "declaration": "(do (binding...) (texpr rexpr...) expr...)", 
        "name": "do"
    }, 
    "s-rest": {
        "description": "Create silence (zero samples) for the given duration at the sample rate *sound-srate*. Default duration is 1.0 sec, and the sound is transformed in time according to *warp*. Note: rest is a Lisp function that is equivalent to cdr. Be careful to use s-rest when you need a sound!", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-rest", 
            "[", 
            "duration", 
            "]"
        ], 
        "declaration": "s-rest([duration])", 
        "name": "s-rest"
    }, 
    "transpose": {
        "description": "Evaluates beh with *transpose* shifted by amount. The effect is relative transposition by amount semitones.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "transpose", 
            "amount", 
            "beh"
        ], 
        "declaration": "transpose(amount, beh)", 
        "name": "transpose"
    }, 
    "pluck": {
        "description": "Returns a sound at the given pitch created using a modified Karplus-Strong plucked string algorithm. The tone decays from an amplitude of about 1.0 to about final-amplitude in duration seconds. The default values are to decay to 0.001 (-60dB) in 1 second. The sample rate is *sound-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pluck", 
            "pitch", 
            "[", 
            "duration", 
            "final-amplitude", 
            "]"
        ], 
        "declaration": "pluck(pitch [, duration, final-amplitude])", 
        "name": "pluck"
    }, 
    "snd-time": {
        "description": "Returns the start time of the sound. This will probably go away in a future version, so use snd-t0 instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-time", 
            "sound"
        ], 
        "declaration": "snd-time(sound)", 
        "name": "snd-time"
    }, 
    "read-int": {
        "description": "stream - the input stream (default is standard input), length - the length of the integer in bytes (default is 4), returns - the integer, Note: Integers are assumed to be big-endian (high-order byte first) and signed, regardless of the platform. To read little-endian format, use a negative number for the length, e.g. -4 indicates a 4-bytes, low-order byte first. The file should be opened in binary mode.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "read-int", 
            "[", 
            "stream", 
            "[", 
            "length", 
            "]", 
            "]"
        ], 
        "declaration": "read-int([stream [, length]])", 
        "name": "read-int"
    }, 
    "interpolate": {
        "description": "Linearly interpolate (or extrapolate) between points (x1, y1) and (x2, y2) to compute the y value corresponding to x.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "interpolate", 
            "x", 
            "x1", 
            "y1", 
            "x2", 
            "y2"
        ], 
        "declaration": "interpolate(x, x1, y1, x2, y2)", 
        "name": "interpolate"
    }, 
    "comb": {
        "description": "Applies a comb filter to sound. A comb filter emphasizes (resonates at) frequencies that are multiples of a hz. The decay time of the resonance is given by decay. This is a variation on feedback-delay (see below). The hz parameter must be a number greater than zero. It is used to compute delay, which is then rounded to the nearest integer number of samples (so the frequency is not always exact. Higher sampling rates yield better delay resolution.) The decay may be a sound or a number. In either case, it must also be positive. (Implementation note: an exponentiation is needed to convert decay into the feedback parameter for feedback-delay, and exponentiation is typically more time-consuming than the filter operation itself. To get high performance, provide decay at a low sample rate.) The resulting sound will have the start time, sample rate, etc. of sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "comb", 
            "sound", 
            "decay", 
            "hz"
        ], 
        "declaration": "comb(sound, decay, hz)", 
        "name": "comb"
    }, 
    "floatp": {
        "description": "expr - the expression to check, returns - t if the value is a float, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "floatp", 
            "expr"
        ], 
        "declaration": "floatp(expr)", 
        "name": "floatp"
    }, 
    "cos": {
        "description": "expr - the floating point number, returns - the cosine of the number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cos", 
            "expr"
        ], 
        "declaration": "cos(expr)", 
        "name": "cos"
    }, 
    "drum": {
        "description": "Create a sound by playing drums sounds associated with track tracknum (a FIXNUM) using pattern patternnum. The tempo is given by bpm in beats per minute. Normally patterns are a sequence of sixteenth notes, so the tempo is in sixteenth notes per minute. For example, if patternnum is 10, then use the pattern specified for beats.10. If the third character of this pattern is 3 and tracknum is 5, then on the third beat, play the soundfile assigned to track.5.3. This function returns a SOUND.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "drum", 
            "tracknum", 
            "patternnum", 
            "bpm"
        ], 
        "declaration": "drum(tracknum, patternnum, bpm)", 
        "name": "drum"
    }, 
    "reverse": {
        "description": "expr - the list to reverse, returns - a new list in the reverse order", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "reverse", 
            "expr"
        ], 
        "declaration": "reverse(expr)", 
        "name": "reverse"
    }, 
    "ramp": {
        "description": "Returns a linear ramp from 0 to 1 over duration (default is 1). The function actually reaches 1 at duration, and therefore has one extra sample, making the total duration be duration + 1/*Control-srate*. See Figure 6 for more detail. Ramp is unaffected by the sustain transformation. The effect of time warping is to warp the starting and ending times only. The ramp itself is unwarped (linear). The sample rate is *control-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "ramp", 
            "[", 
            "duration", 
            "]"
        ], 
        "declaration": "ramp([duration])", 
        "name": "ramp"
    }, 
    "equal": {
        "description": "expr1 - the first expression, expr2 - the second expression, returns - t if they are equal, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "equal", 
            "expr1", 
            "expr2"
        ], 
        "declaration": "equal(expr1, expr2)", 
        "name": "equal"
    }, 
    "control-warp": {
        "description": "Applies a warp function warp-fn to signal using function composition. If wrate is omitted, linear interpolation is used. warp-fn is a mapping from score (logical) time to real time, and signal is a function from score time to real values. The result is a function from real time to real values at a sample rate of *control-srate*. See sound-warp for an explanation of wrate and high-quality warping.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "control-warp", 
            "warp-fn", 
            "signal", 
            "[", 
            "wrate", 
            "]"
        ], 
        "declaration": "control-warp(warp-fn, signal,   [wrate])", 
        "name": "control-warp"
    }, 
    "osc-pulse": {
        "description": "Returns a square pulse with variable width at the indicated frequency (in Hertz). The bias parameter controls the pulse width and should be between -1 and +1, giving a pulse width from 0% (always at -1) to 100% (always at +1). When bias is zero, a square wave is generated. Bias may be a SOUND to create varying pulse width. If bias changes rapidly, strange effects may occur. The optional compare-shape defaults to a hard step at zero, but other shapes may be used to achieve non-square pulses. The osc-pulse behavior is written in terms of other behaviors and defined in the file nyquist.lsp using just a few lines of code. Read the code for the complete story.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "osc-pulse", 
            "hz", 
            "bias", 
            "[", 
            "compare-shape", 
            "]"
        ], 
        "declaration": "osc-pulse(hz, bias [, compare-shape])", 
        "name": "osc-pulse"
    }, 
    "score-set-begin": {
        "description": "The begin time from the score's SCORE-BEGIN-END marker is set to time. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-set-begin", 
            "score", 
            "time"
        ], 
        "declaration": "score-set-begin(score, time)", 
        "name": "score-set-begin"
    }, 
    "soundfilename": {
        "description": "Converts a string name to a soundfile name. If name begins with \".\" or \"/\", the name is returned without alteration. Otherwise, a path taken from *default-sf-dir* is prepended to name. The s-plot, s-read, and s-save functions all use soundfilename translate filenames.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "soundfilename", 
            "name"
        ], 
        "declaration": "soundfilename(name)", 
        "name": "soundfilename"
    }, 
    "eq-highshelf": {
        "description": "A fixed-parameter, second-order treble shelving equalization (EQ) filter based on snd-biquad. The hz parameter (a FLONUM)is the halfway point in the transition, and gain (a FLONUM) is the treble boost (or cut) in dB. The optional slope (a FLONUM) is 1.0 by default, and response becomes peaky at values greater than 1.0.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "eq-highshelf", 
            "signal", 
            "hz", 
            "gain", 
            "[", 
            "slope", 
            "]"
        ], 
        "declaration": "eq-highshelf(signal, hz, gain [, slope])", 
        "name": "eq-highshelf"
    }, 
    "drum-loop": {
        "description": "Repeat the sound given by snd numtimes times. The repetitions occur at a time offset of duration, regardless of the actual duration of snd. A SOUND is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "drum-loop", 
            "snd", 
            "duration", 
            "numtimes"
        ], 
        "declaration": "drum-loop(snd, duration, numtimes)", 
        "name": "drum-loop"
    }, 
    "buzz": {
        "description": "Returns a sound with n harmonics of equal amplitude and a total amplitude of 1.0, using a well-known function of two cosines. If n (an integer) is less than 1, it is set to 1. Aliasing will occur if n is too large. The duration is determined by the duration of the sound modulation, which is a frequency modulation term expressed in Hz (see Section \"Oscillators\"). Negative frequencies are correctly handled. The sample rate is *sound-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "buzz", 
            "n", 
            "pitch", 
            "modulation"
        ], 
        "declaration": "buzz(n, pitch, modulation)", 
        "name": "buzz"
    }, 
    "continuous-control-warp": {
        "description": "Applies the current warp environment to the signal returned by beh. The result has the default control sample rate *control-srate*. Linear interpolation is currently used. Implementation: beh is first evaluated without any shifting, stretching, or warping. The result is functionally composed with the inverse of the environment's warp function.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "continuous-control-warp", 
            "beh"
        ], 
        "declaration": "continuous-control-warp(beh)", 
        "name": "continuous-control-warp"
    }, 
    "snd-amosc": {
        "description": "An oscillator with amplitude modulation. The sound am specifies the amplitude and the logical stop time. The physical stop time is also that of am. You should use amosc instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-amosc", 
            "sound", 
            "step", 
            "sr", 
            "hz", 
            "t0", 
            "am", 
            "phase"
        ], 
        "declaration": "snd-amosc(sound, step, sr, hz, t0,am, phase)", 
        "name": "snd-amosc"
    }, 
    "load": {
        "description": "fname - the filename string or symbol, :verbose - the verbose flag (default is t), :print - the print flag (default is nil), returns - the filename", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "load", 
            "fname", 
            "key", 
            ":verbose", 
            ":print"
        ], 
        "declaration": "(load fname key :verbose :print)", 
        "name": "load"
    }, 
    "scale-db": {
        "description": "Scales the amplitude of sound by the factor db, expressed in decibels. Sample rates, start times, etc. are taken from sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "scale-db", 
            "db", 
            "sound"
        ], 
        "declaration": "scale-db(db, sound)", 
        "name": "scale-db"
    }, 
    "snd-play": {
        "description": "Evaluates expression to obtain a sound or array of sounds, computes all of the samples (without retaining them in memory), and returns. Originally, this was a placeholder for a facility to play samples directly to an audio output device, but playback is now accomplished by s-save. Meanwhile, since this function does not save samples in memory or write them to a disk, it is useful in determining how much time is spent calculating samples. See s-save (Section \"Sound File Input and Output\") for saving samples to a file, and play (Section \"Sound File Input and Output\") to play a sound. This function is safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-play", 
            "expression"
        ], 
        "declaration": "snd-play(expression)", 
        "name": "snd-play"
    }, 
    "snd-fmosc": {
        "description": "A Frequency Modulation oscillator. The sound fm specifies frequency deviation (in Hertz) from hz. You should use fmosc instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-fmosc", 
            "s", 
            "step", 
            "sr", 
            "hz", 
            "t0", 
            "fm", 
            "phase"
        ], 
        "declaration": "snd-fmosc(s, step, sr, hz, t0, fm,phase)", 
        "name": "snd-fmosc"
    }, 
    "make-string-input-stream": {
        "description": "str - the string, start - the starting offset, end - the ending offset + 1, returns - an unnamed stream that reads from the string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-string-input-stream", 
            "str", 
            "[", 
            "start", 
            "[", 
            "end", 
            "]", 
            "]"
        ], 
        "declaration": "make-string-input-stream(str [, start [, end]])", 
        "name": "make-string-input-stream"
    }, 
    "score-print": {
        "description": "Print a score with one note per line. Returns nil.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-print", 
            "score"
        ], 
        "declaration": "score-print(score)", 
        "name": "score-print"
    }, 
    "snd-pluck": {
        "description": "A Karplus-Strong plucked string oscillator with sample rate sr, fundamental frequency hz, starting time t0, duration d, initial amplitude approximately 1.0 (not exact because the string is initialized with random values) and final amplitude approximately final-amp. You should use pluck instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-pluck", 
            "sr", 
            "hz", 
            "t0", 
            "d", 
            "final-amp"
        ], 
        "declaration": "snd-pluck(sr, hz, t0, d, final-amp)", 
        "name": "snd-pluck"
    }, 
    "make-random": {
        "description": "Make a random pattern that selects from items. Any (or all) element(s) of items may be lists of the following form: (value :weight weight :min mincount :max maxcount), where value is the item (or pattern) to be generated, weight is the (optional) relative probability of selecting this item, mincount is the (optional) minimum number of repetitions when this item is selected, and maxcount is the (optional) maximum number of repetitions allowed before selecting some other item. The default period length is the length of items. If items is a pattern, a period from that pattern becomes the list from which random selections are made, and a new list is generated every period.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-random", 
            "items", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-random(items, for: for, name: name, trace: trace)", 
        "name": "make-random"
    }, 
    "pop": {
        "description": "Remove (pop) the first item from lis (a Lisp list). This is a macro that is equivalent to writing (in Lisp) (setf lis (cdr lis)). Note that the remaining list is returned, not the head of the list that has been popped. Retrieve the head of the list (i.e. the top of the stack) using first or, equivalently, car.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pop", 
            "lis"
        ], 
        "declaration": "pop(lis)", 
        "name": "pop"
    }, 
    "snd-maxsamp": {
        "description": "Computes the maximum of the absolute value of the samples in sound. Calling this function will cause samples to be computed and saved in memory. (This function should have a maxlen parameter to allow self-defense against sounds that would exhaust available memory.) Otherwise, this function is safe for ordinary use. This function will probably be removed in a future version. See peak, a replacement (\"Signal Operations\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-maxsamp", 
            "sound"
        ], 
        "declaration": "snd-maxsamp(sound)", 
        "name": "snd-maxsamp"
    }, 
    "snd-clarinet-all": {
        "description": "A clarinet model just like snd-clarinet-freq but with additional parameters for vibrato generation and continuous control of reed stiffness and breath noise. You should use clarinet-all instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-clarinet-all", 
            "freq", 
            "vibrato-freq", 
            "vibrato-gain", 
            "freq-env", 
            "breath-env", 
            "reed-stiffness", 
            "noise", 
            "sr"
        ], 
        "declaration": "snd-clarinet-all(freq, vibrato-freq,vibrato-gain, freq-env, breath-env,reed-stiffness, noise, sr)", 
        "name": "snd-clarinet-all"
    }, 
    "snd-resamplev": {
        "description": "Compose two signals, i.e. compute f(g(t)), where f and g are sounds. The result has sample rate given by rate. At each time t (according to the rate), g is linearly interpolated to yield an increasing sequence of high-precision score-time values. f is then interpolated at each value to yield a result sample. If in fact g decreases, the current sample of g is replaced by the previous one, forcing g into compliance with the non-decreasing restriction. The result is scaled by 0.95 because often, in resampling, interpolated values exceed the original sample values, and this could lead to clipping. Note that if g has a high sample rate, this may introduce unwanted jitter into sample times. See sound-warp for a detailed discussion. See snd-compose for a fast, low-quality alternative to this function. Normally, you should use sound-warp instead of this function.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-resamplev", 
            "f", 
            "rate", 
            "g"
        ], 
        "declaration": "snd-resamplev(f, rate, g)", 
        "name": "snd-resamplev"
    }, 
    "snd-samples": {
        "description": "Converts the samples into a lisp array. The data is taken directly from the samples, ignoring shifts. For example, if the sound starts at 3.0 seconds, the first sample will refer to time 3.0, not time 0.0. A maximum of limit samples is returned. This function is safe for ordinary use, but like snd-from-array, it requires a total of slightly over 18 bytes per sample.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-samples", 
            "sound", 
            "limit"
        ], 
        "declaration": "snd-samples(sound, limit)", 
        "name": "snd-samples"
    }, 
    "diff": {
        "description": "Returns the difference between a and b. This function is defined as (sum a (prod -1 b)).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "diff", 
            "a", 
            "b"
        ], 
        "declaration": "diff(a, b)", 
        "name": "diff"
    }, 
    "nstring-downcase": {
        "description": "str - the string, :start - the starting offset, :end - the ending offset + 1, returns - the converted string (not a copy)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "nstring-downcase", 
            "str", 
            "start:", 
            "start", 
            "end:", 
            "end"
        ], 
        "declaration": "nstring-downcase(str, start: start, end: end)", 
        "name": "nstring-downcase"
    }, 
    "prog2": {
        "description": "expr1 - the first expression to evaluate, expr2 - the second expression to evaluate, expr - the remaining expressions to evaluate, returns - the value of the second expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "prog2", 
            "expr1", 
            "expr2", 
            "expr..."
        ], 
        "declaration": "prog2(expr1, expr2, expr...)", 
        "name": "prog2"
    }, 
    "snd-stkpitshift": {
        "description": "A pitch shifter implemented in STK. The sound is shifted in pitch by shift, a FLONUM representing the shift factor. A value of 1.0 means no shift. The parameter mix sets the mixture of input and shifted sounds. A value of 0.0 means input only (dry) and a value of 1.0 means shifted sound only (wet). You should use pitshift instead (see Section \"Effects\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-stkpitshift", 
            "sound", 
            "shift", 
            "mix"
        ], 
        "declaration": "snd-stkpitshift(sound, shift, mix)", 
        "name": "snd-stkpitshift"
    }, 
    "stretch": {
        "description": "Evaluates beh with *warp* scaled by factor. The effect is to \"stretch\" the result of beh (under the current environment) by factor. See Chapter \"Continuous Transformations and Time Warps\" for more information. Use get-duration(dur) to get the nominal actual duration of a behavior that locally has a duration of dur. Here, \"nominal\" means what would be expected if the behavior obeys the shift, stretch, and warp components of the environment. (Any behavior is free to deviate from the nominal timing. For example, a percussion sound might have a fixed duration independent of the stretch factor.) Also, \"actual\" means global or absolute time, and \"locally\" means within the environment where get-duration is called. get-duration works by mapping the current time (local time 0) using local-to-global to obtain an actual start time, and mapping dur to obtain an actual end time. The difference is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "stretch", 
            "factor", 
            "beh"
        ], 
        "declaration": "stretch(factor, beh)", 
        "name": "stretch"
    }, 
    "snd-fromarraystream": {
        "description": "Creates a sound for which samples come from object. The starting time is t0 (a FLONUM), and the sample rate is sr. The object is an XLISP object (see Section \"Objects\" for information on objects.) A sound is returned. When the sound needs samples, they are generated by sending the message :next to object. If object returns NIL, the sound terminates. Otherwise, object must return an array of FLONUMs. The values in these arrays are concatenated to form the samples of the resulting sound. There is no provision for object to specify the logical stop time of the sound, so the logical stop time is the termination time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-fromarraystream", 
            "t0", 
            "sr", 
            "object"
        ], 
        "declaration": "snd-fromarraystream(t0, sr, object)", 
        "name": "snd-fromarraystream"
    }, 
    "trigger": {
        "description": "Returns a sound which is the sum of instances of the behavior beh. One instance is created each time SOUND s makes a transition from less than or equal to zero to greater than zero. (If the first sample of s is greater than zero, an instance is created immediately.) The sample rate of s and all behaviors must be the same, and the behaviors must be (monophonic) SOUNDs. This function is particularly designed to allow behaviors to be invoked in real time by making s a function of a Nyquist slider, which can be controlled by a graphical interface or by OSC messages. See snd-slider in Section \"Creating Sounds\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "trigger", 
            "s", 
            "beh"
        ], 
        "declaration": "trigger(s, beh)", 
        "name": "trigger"
    }, 
    "make-accumulation": {
        "description": "For each item, generate items from the first to the item including the item. The period length is (n^(2) + n) / 2 where n is the length of items. If items is a pattern, a period from that pattern becomes the list from which items are generated, and a new list is generated every period. Note that this is similar in name but different from make-accumulate.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-accumulation", 
            "items", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-accumulation(items, name: name, trace: trace)", 
        "name": "make-accumulation"
    }, 
    "params-scale": {
        "description": "Scale a score event parameter by some factor. This is like params-transpose, only using multiplication. The params list is a list of keyword/value pairs, keyword is the parameter keyword, and amount is the scale factor.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "params-scale", 
            "params", 
            "keyword", 
            "amount"
        ], 
        "declaration": "params-scale(params, keyword, amount)", 
        "name": "params-scale"
    }, 
    "score-stretch-to-length": {
        "description": "Stretch the score so that the end time of the score is the score's begin time plus length. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-stretch-to-length", 
            "score", 
            "length"
        ], 
        "declaration": "score-stretch-to-length(score, length)", 
        "name": "score-stretch-to-length"
    }, 
    "piano-midi": {
        "description": "Use the piano synthesizer to play a MIDI file. The file name (a string) is given by midi-file-name.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "piano-midi", 
            "midi-file-name"
        ], 
        "declaration": "piano-midi(midi-file-name)", 
        "name": "piano-midi"
    }, 
    "minusp": {
        "description": "expr - the number to test, returns - t if the number is negative, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "minusp", 
            "expr"
        ], 
        "declaration": "minusp(expr)", 
        "name": "minusp"
    }, 
    "get-warp": {
        "description": "Gets a function corresponding to the current value of the *warp* environment variable. For efficiency, *warp* is stored in three parts representing a shift, a scale factor, and a continuous warp function. Get-warp is used to retrieve a signal that maps logical time to real time. This signal combines the information of all three components of *warp* into a single signal. If the continuous warp function component is not present (indicating that the time warp is a simple combination of at and stretch transformations), an error is raised. This function is mainly for internal system use. In the future, get-warp will probably be reimplemented to always return a signal and never raise an error.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-warp"
        ], 
        "declaration": "get-warp()", 
        "name": "get-warp"
    }, 
    "catch": {
        "description": "sym - the catch tag, expr - expressions to evaluate, returns - the value of the last expression the throw expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "catch", 
            "sym", 
            "expr..."
        ], 
        "declaration": "catch(sym, expr...)", 
        "name": "catch"
    }, 
    "last": {
        "description": "list - the list, returns - the last list node in the list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "last", 
            "list"
        ], 
        "declaration": "last(list)", 
        "name": "last"
    }, 
    "set-logical-stop": {
        "description": "Returns a sound with time as the logical stop time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "set-logical-stop", 
            "beh", 
            "time"
        ], 
        "declaration": "set-logical-stop(beh, time)", 
        "name": "set-logical-stop"
    }, 
    "dribble": {
        "description": "fname - file name string or symbol (if missing, close current transcript), returns - t if the transcript is opened, nil if it is closed", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "dribble", 
            "[", 
            "fname", 
            "]"
        ], 
        "declaration": "dribble([fname])", 
        "name": "dribble"
    }, 
    "untrace": {
        "description": "sym - the function to remove (quoted), returns - the trace list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "untrace", 
            "sym"
        ], 
        "declaration": "untrace(sym)", 
        "name": "untrace"
    }, 
    "sound": {
        "description": "Applies *loud*, *warp*, *start*, and *stop* to sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sound", 
            "sound"
        ], 
        "declaration": "sound(sound)", 
        "name": "sound"
    }, 
    "bilateral-exponential-dist": {
        "description": "Returns a FLONUM value from a bilateral exponential distribution, where xmu is the center of the double exponential and tau controls the spread of the distribution. A larger tau gives a wider distribution (greater variance), and tau must be greater than zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively. This distribution is similar to the exponential, except it is centered at 0 and can output negative values as well. Like the exponential, it can be used to generate time intervals; however, it might be necessary to add a lower bound so as not to compute a negative time interval.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "bilateral-exponential-dist", 
            "xmu", 
            "tau", 
            "[", 
            "low", 
            "high", 
            "]"
        ], 
        "declaration": "bilateral-exponential-dist(xmu, tau [, low, high])", 
        "name": "bilateral-exponential-dist"
    }, 
    "make-product": {
        "description": "Form products of items (which must be numbers) from pattern x and pattern or number y. The default period lengths match the period lengths from x.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-product", 
            "x", 
            "y", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-product(x, y, for: for, name: name, trace: trace)", 
        "name": "make-product"
    }, 
    "while": {
        "description": "A conventional \"while\" loop. If test is true, evaluate expressions (expr1, expr2, etc.) and repeat. If test is false, return. This expression evaluates to NIL unless the expression (return expr) is evaluated, in which case the value of expr is returned. In SAL, the loop statement is preferred.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "while", 
            "test", 
            "expr1", 
            "expr2", 
            "..."
        ], 
        "declaration": "while(test, expr1, expr2, ...)", 
        "name": "while"
    }, 
    "*autonorm*": {
        "description": "The normalization factor to be applied to the next sound when *autonorm-type* is 'previous. See Sections \"Memory Space and Normalization\" and \"Sound File Input and Output\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*autonorm*"
        ], 
        "declaration": "*autonorm*", 
        "name": "*autonorm*"
    }, 
    "write-char": {
        "description": "ch - the character to write, stream - the output stream (default is standard output), returns - the character", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "write-char", 
            "ch", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "write-char(ch  [, stream])", 
        "name": "write-char"
    }, 
    "error": {
        "description": "emsg - the error message string, arg - the argument expression (printed after the message), returns - never returns", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "error", 
            "emsg", 
            "[", 
            "arg", 
            "]"
        ], 
        "declaration": "error(emsg [, arg])", 
        "name": "error"
    }, 
    "highpass2": {
        "description": "A fixed-parameter, second-order highpass filter based on snd-biquad. The cutoff frequency is given by hz (a FLONUM) and an optional Q factor is given by q (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "highpass2", 
            "signal", 
            "hz", 
            "[", 
            "q", 
            "]"
        ], 
        "declaration": "highpass2(signal, hz [, q])", 
        "name": "highpass2"
    }, 
    "*sound-srate*": {
        "description": "Part of the environment, establishes the audio sample rate. See Section \"The Environment\" for details.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*sound-srate*"
        ], 
        "declaration": "*sound-srate*", 
        "name": "*sound-srate*"
    }, 
    "loop": {
        "description": "expr - the body of the loop, returns - never returns (must use non-local exit)", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "loop", 
            "expr..."
        ], 
        "declaration": "(loop expr...)", 
        "name": "loop"
    }, 
    "cons": {
        "description": "expr1 - the car of the new list node, expr2 - the cdr of the new list node, returns - the new list node", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cons", 
            "expr1", 
            "expr2"
        ], 
        "declaration": "cons(expr1, expr2)", 
        "name": "cons"
    }, 
    "snd-recip": {
        "description": "Compute the reciprocal of each sample of sound. Use recip instead (see Section \"More Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-recip", 
            "sound"
        ], 
        "declaration": "snd-recip(sound)", 
        "name": "snd-recip"
    }, 
    "char-code": {
        "description": "chr - the character, returns - the ascii character code (integer)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "char-code", 
            "chr"
        ], 
        "declaration": "char-code(chr)", 
        "name": "char-code"
    }, 
    "simrep": {
        "description": "Iteratively evaluates beh with the atom var set with values from 0 to limit-1, inclusive. These sounds are then placed simultaneously in time as if by sim. In LISP, the syntax is (seqrep (var limit) beh).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "simrep", 
            "var", 
            "limit", 
            "beh"
        ], 
        "declaration": "simrep(var, limit, beh)", 
        "name": "simrep"
    }, 
    "sref-inverse": {
        "description": "Search sound for the first point at which it achieves value and return the corresponding (linearly interpolated) time. If no inverse exists, an error is raised. This function is used by Nyquist in the implementation of time warping.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sref-inverse", 
            "sound", 
            "value"
        ], 
        "declaration": "sref-inverse(sound, value)", 
        "name": "sref-inverse"
    }, 
    "cxxr": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cxxr", 
            "expr"
        ], 
        "declaration": "cxxr(expr)", 
        "name": "cxxr"
    }, 
    "sitar": {
        "description": "A sitar physical model implemented in STK. The parameter step is a FLONUM that sets the pitch, and dur is the duration.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sitar", 
            "step", 
            "dur"
        ], 
        "declaration": "sitar(step, dur)", 
        "name": "sitar"
    }, 
    "osc-enable": {
        "description": "Enable or disable Open Sound Control. (See Appendix \"Open Sound Control and Nyquist\".) Enabling creates a socket and a service that listens for UDP packets on port 7770. Currently, only two messages are accepted by Nyquist. The first is of the form /slider with an integer index and a floating point value. These set internal slider values accessed by the snd-slider function. The second is of the form /wii/orientation with two floating point values. This message is a special case to support the DarwiinRemoteOsc program which can relay data from a Nintendo WiiMote device to Nyquist via OSC. The two orientation values control sliders 0 and 1. Disabling terminates the service (polling for messages) and closes the socket. The previous state of enablement is returned, e.g. if OSC is enabled and flag is nil, OSC is disabled and T (true) is returned because OSC was enabled at the time of the call. This function only exists if Nyquist is compiled with the compiler flag OSC. Otherwise, the function exists but always returns the symbol DISABLED. Consider lowering the audio latency using snd-set-latency. Warning: there is the potential for network-based attacks using OSC. It is tempting to add the ability to evaluate XLISP expressions sent via OSC, but this would create unlimited and unprotected access to OSC clients. For now, it is unlikely that an attacker could do more than manipulate slider values.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "osc-enable", 
            "flag"
        ], 
        "declaration": "osc-enable(flag)", 
        "name": "osc-enable"
    }, 
    "symbol-plist": {
        "description": "sym - the symbol, returns - the symbol's property list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "symbol-plist", 
            "sym"
        ], 
        "declaration": "symbol-plist(sym)", 
        "name": "symbol-plist"
    }, 
    "cond": {
        "description": "pair - pair consisting of:, (pred expr...) where: pred - is a predicate expression, expr - evaluated if the predicate is not nil returns - the value of the first expression whose predicate is not nil", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "cond", 
            "pair..."
        ], 
        "declaration": "(cond pair...)", 
        "name": "cond"
    }, 
    "lpc-frame-filter-coefs": {
        "description": "Get the filter coefficients from a frame.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lpc-frame-filter-coefs", 
            "frame"
        ], 
        "declaration": "lpc-frame-filter-coefs(frame)", 
        "name": "lpc-frame-filter-coefs"
    }, 
    "if": {
        "description": "texpr - the test expression, expr1 - the expression to be evaluated if texpr is non-nil, expr2 - the expression to be evaluated if texpr is nil, returns - the value of the selected expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "if", 
            "texpr", 
            "expr1", 
            "[", 
            "expr2", 
            "]"
        ], 
        "declaration": "if(texpr, expr1 [, expr2])", 
        "name": "if"
    }, 
    "null": {
        "description": "expr - the list to check, returns - t if the list is empty, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "null", 
            "expr"
        ], 
        "declaration": "null(expr)", 
        "name": "null"
    }, 
    "continuous-sound-warp": {
        "description": "Applies the current warp environment to the signal returned by beh. The result has the default sound sample rate *sound-srate*. Linear interpolation is currently used. See continuous-control-warp for implementation notes.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "continuous-sound-warp", 
            "beh"
        ], 
        "declaration": "continuous-sound-warp(beh)", 
        "name": "continuous-sound-warp"
    }, 
    "snd-coterm": {
        "description": "Returns a copy of s1, except the start time is the maximum of the start times of s1 and s2, and the termination time is the minimum of s1 and s2. (After the termination time, the sound is zero as if s1 is gated by s2.) Some rationale follows: In order to implement s-add-to, we need to read from the target sound file, add the sounds to a new sound, and overwrite the result back into the file. We only want to write as many samples into the file as there are samples in the new sound. However, if we are adding in samples read from the file, the result of a snd-add in Nyquist will have the maximum duration of either sound. Therefore, we may read to the end of the file. What we need is a way to truncate the read, but we cannot easily do that, because we do not know in advance how long the new sound will be. The solution is to use snd-coterm, which will allow us to truncate the sound that is read from the file (s1) according to the duration of the new sound (s2). When this truncated sound is added to the new sound, the result will have only the duration of the new sound, and this can be used to overwrite the file. This function is used in the implementation of s-add-to, which is defined in runtime/fileio.lsp.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-coterm", 
            "s1", 
            "s2"
        ], 
        "declaration": "snd-coterm(s1, s2)", 
        "name": "snd-coterm"
    }, 
    "remove-if": {
        "description": "test - the test predicate, list - the list, returns - copy of list with matching elements removed", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "remove-if", 
            "test", 
            "list"
        ], 
        "declaration": "remove-if(test, list)", 
        "name": "remove-if"
    }, 
    "sqrt": {
        "description": "expr - the floating point number, returns - the square root of the number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sqrt", 
            "expr"
        ], 
        "declaration": "sqrt(expr)", 
        "name": "sqrt"
    }, 
    "grindef": {
        "description": "Prints a formatted listing of a lisp function. This is often useful to quickly inspect a function without searching for it in source files. Do not forget to quote the name, e.g. (grindef 'prod).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "grindef", 
            "name"
        ], 
        "declaration": "grindef(name)", 
        "name": "grindef"
    }, 
    "incf": {
        "description": "Increment symbol by one. This is a macro, and symbol can be anything that can be set by setf. Typically, symbol is a variable: \"(incf i),\" but symbol can also be an array element: \"(incf (aref myarray i)).\"", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "incf", 
            "symbol"
        ], 
        "declaration": "incf(symbol)", 
        "name": "incf"
    }, 
    "sound-off": {
        "description": "Disable real-time audio output when sound is computed by the the play command.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sound-off"
        ], 
        "declaration": "sound-off()", 
        "name": "sound-off"
    }, 
    "score-merge": {
        "description": "Create a new score containing all the notes of the parameters, which are all scores. The resulting notes retain their original times and durations. The merged score begin time is the minimum of the begin times of the parameters and the merged score end time is the maximum of the end times of the parameters. The original scores are not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-merge", 
            "score1", 
            "score2", 
            "..."
        ], 
        "declaration": "score-merge(score1, score2, ...)", 
        "name": "score-merge"
    }, 
    "listdir": {
        "description": "path - the path of the directory to be listed, returns - list of filenames in the directory", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "listdir", 
            "path"
        ], 
        "declaration": "listdir(path)", 
        "name": "listdir"
    }, 
    "snd-avg": {
        "description": "Computes the averages or peak values of blocks of samples. Each output sample is an average or peak of blocksize (a fixnum) adjacent samples from the input sound. After each average or peak is taken, the input is advanced by stepsize, a fixnum which may be greater or less than blocksize. The output sample rate is the sound (input) sample rate divided by stepsize. The duration of the output is the same (approximately, due to rounding) as that of sound. Notice however, that the features of the input will appear earlier in the output by half the window size. For example, a sharp peak in the input will result in a smoothed peak (using OP-AVERAGE) one half blocksize earlier. You can correct for this shift by inserting one half blocksize of silence before sound, e.g. if s has a sample rate of 44100 Hz, then snd-avg(seq(s-rest(0.01), cue(s)), 882, 441, OP-AVERAGE) will shift s by 0.01 s to compensate for the shift introduced by a smoothing window of size 0.02 s (882/44100). This function is useful for computing low-sample-rate rms or peak amplitude signals for input to snd-gate or snd-follow. To select the operation, operation should be one of OP-AVERAGE or OP-PEAK. (These are global lisp variables; the actual operation parameter is an integer.) For RMS computation, see rms in Section \"More Behaviors\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-avg", 
            "sound", 
            "blocksize", 
            "stepsize", 
            "operation"
        ], 
        "declaration": "snd-avg(sound, blocksize, stepsize, operation)", 
        "name": "snd-avg"
    }, 
    "arc-sine-dist": {
        "description": "Returns a FLONUM value from the arc sine distribution, which outputs values between 0 and 1. It is symetric about the mean of 1/2, but is more likely to generate values closer to 0 and 1.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "arc-sine-dist"
        ], 
        "declaration": "arc-sine-dist()", 
        "name": "arc-sine-dist"
    }, 
    "streamp": {
        "description": "expr - the expression to check, returns - t if the value is a stream, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "streamp", 
            "expr"
        ], 
        "declaration": "streamp(expr)", 
        "name": "streamp"
    }, 
    "build-harmonic": {
        "description": "Intended for constructing wavetables, this function returns a sound of length table-size samples containing n periods of a sinusoid. These can be scaled and summed to form a waveform with the desired harmonic content. See \"Waveforms\" for an example.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "build-harmonic", 
            "n", 
            "table-size"
        ], 
        "declaration": "build-harmonic(n, table-size)", 
        "name": "build-harmonic"
    }, 
    "characterp": {
        "description": "expr - the expression to check, returns - t if the value is a character, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "characterp", 
            "expr"
        ], 
        "declaration": "characterp(expr)", 
        "name": "characterp"
    }, 
    "apply-banded-delay": {
        "description": "Separates input SOUND s into FIXNUM num-bands bands from a low frequency of lowp to a high frequency of highp (these are FLONUMS that specify steps, not Hz), and applies a delay to each band. The delay for the lowest band is given by the FLONUM lowd (in seconds) and the delay for the highest band is given by the FLONUM highd. The delays for other bands are linearly interpolated between these values. Each delay has feedback gain controlled by FLONUM fb. The delayed bands are scaled by FLONUM wet, and the original sound is scaled by 1 - wet. All are summed to form the result, a SOUND.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "apply-banded-delay", 
            "s", 
            "lowp", 
            "highp", 
            "num-bands", 
            "lowd", 
            "highd", 
            "fb", 
            "wet"
        ], 
        "declaration": "apply-banded-delay(s, lowp, highp, num-bands, lowd, highd, fb, wet)", 
        "name": "apply-banded-delay"
    }, 
    "snd-resonvv": {
        "description": "This function is identical to snd-reson except botth hz (center frequency) and bw (bandwidth) are sounds. Filter coefficients are updated at the next sample from either hz or bw. You should use reson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-resonvv", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-resonvv(sound, hz, bw,normalization)", 
        "name": "snd-resonvv"
    }, 
    "snd-sampler": {
        "description": "Returns a sound constructed by reading a sample from beginning to end and then splicing on copies of the same sound from a loop point to the end. The sound s is the source sound to be looped, and step (a FLONUM) is the nominal fundamental frequency (in steps, not Hz) of s. The start (a FLONUM) is the time in seconds at which to start the loop, sr (a FLONUM) is the desired sample rate of the output, hz is the nominal fundamental frequency of the output, t0 (a FLONUM) is the starting time of the output, and fm (a SOUND) is frequency modulation that is added to hz to determine the output fundamental frequency. The parameter npoints (a FIXNUM) specifies how many points should be used for sample interpolation. Currently this parameter defaults to 2 and only 2-point (linear) interpolation is implemented. It is an error to modulate such that the frequency is negative. Note also that the loop point may be fractional. This function implements a typical sampling synthesis algorithm, looping and resampling the input according to the ratio between the desired fundamental frequency (which is the sum of hz and fm) and the nominal fundamental of the looped sound (which is assumed to be given by step). You should use sampler instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sampler", 
            "s", 
            "step", 
            "start", 
            "sr", 
            "hz", 
            "t0", 
            "fm", 
            "npoints"
        ], 
        "declaration": "snd-sampler(s, step,start, sr, hz, t0, fm, npoints)", 
        "name": "snd-sampler"
    }, 
    "expand": {
        "description": "num - the number of segments to add, returns - the number of segments added", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "expand", 
            "num"
        ], 
        "declaration": "expand(num)", 
        "name": "expand"
    }, 
    "save-lpc-file": {
        "description": "Create a file containing LPC frames. This file can be read by make-lpc-file-iterator (see above).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "save-lpc-file", 
            "lpc-iterator", 
            "filename"
        ], 
        "declaration": "save-lpc-file(lpc-iterator, filename)", 
        "name": "save-lpc-file"
    }, 
    "snd-pwl": {
        "description": "Computes a piece-wise linear function according to the breakpoints in lis. The starting time is t0, and the sample rate is sr. The breakpoints are passed in an XLISP list (of type LVAL) where the list alternates sample numbers (FIXNUMs, computed in samples from the beginning of the pwl function) and values (the value of the pwl function, given as a FLONUM). There is an implicit starting point of (0, 0). The list must contain an odd number of points, the omitted last value being implicitly zero (0). The list is assumed to be well-formed. Do not call this function. Use pwl instead (see Section \"Piece-wise Approximations\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-pwl", 
            "t0", 
            "sr", 
            "lis"
        ], 
        "declaration": "snd-pwl(t0, sr,lis)", 
        "name": "snd-pwl"
    }, 
    "save-workspace": {
        "description": "All global variables in the workspace are saved to workspace.lsp (in the current directory), overwriting the previous file.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "save-workspace"
        ], 
        "declaration": "save-workspace()", 
        "name": "save-workspace"
    }, 
    "setf": {
        "description": "place - the field specifier (quoted):, sym - set value of a symbol, (car expr) - set car of a cons node, (cdr expr) - set cdr of a cons node, (nth n expr) - set nth car of a list, (aref expr n) - set nth element of an array, (get sym prop) - set value of a property, (symbol-value sym) - set value of a symbol, (symbol-function sym) - set functional value of a symbol, (symbol-plist sym) - set property list of a symbol, expr - the new value, returns - the new value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "setf", 
            "[", 
            "place", 
            "expr", 
            "]", 
            "..."
        ], 
        "declaration": "setf([place, expr]...)", 
        "name": "setf"
    }, 
    "bernoulli-dist": {
        "description": "Returns either x1 (default value is 1) with probability px1 or x2 (default value is 0) with probability 1 - px1. The value of px1 should be between 0 and 1. By convention, a result of x1 is viewed as a success while x2 is viewed as a failure.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "bernoulli-dist", 
            "px1", 
            "[", 
            "x1", 
            "x2", 
            "]"
        ], 
        "declaration": "bernoulli-dist(px1 [, x1, x2])", 
        "name": "bernoulli-dist"
    }, 
    "symbol-value": {
        "description": "sym - the symbol, returns - the symbol's value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "symbol-value", 
            "sym"
        ], 
        "declaration": "symbol-value(sym)", 
        "name": "symbol-value"
    }, 
    "warp-abs": {
        "description": "Evaluates beh with *warp* set to fn. In other words, the current *warp* is ignored and not composed with fn to form the new *warp*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "warp-abs", 
            "fn", 
            "beh"
        ], 
        "declaration": "warp-abs(fn, beh)", 
        "name": "warp-abs"
    }, 
    "linear-to-db": {
        "description": "Returns the conversion of x from linear to decibels. 1 is converted to 0. 0 is converted to -INF (a special IEEE floating point value.) A factor of 10 represents a 20dB change. If x is a sound, each sample is converted and a sound is returned. If x is a multichannel sound, each channel is converted and a multichannel sound (array) is returned. Note: With sounds, conversion is only performed on actual samples, not on the implicit zeros before the beginning and after the termination of the sound. Start times, sample rates, etc. are taken from x.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "linear-to-db", 
            "x"
        ], 
        "declaration": "linear-to-db(x)", 
        "name": "linear-to-db"
    }, 
    "snd-compose": {
        "description": "Compose two signals, i.e. compute f(g(t)), where f and g are sounds. This function is used primarily to implement time warping, but it can be used in other applications such as frequency modulation. For each sample x in g, snd-compose looks up the value of f(x) using linear interpolation. The resulting sample rate, start time, etc. are taken from g. The sound f is used in effect as a lookup table, but it is assumed that g is non-decreasing, so that f is accessed in time order. This allows samples of f to be computed and discarded incrementally. If in fact g decreases, the current sample of g is replaced by the previous one, forcing g into compliance with the non-decreasing restriction. See also sref, shape, and snd-resample.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-compose", 
            "f", 
            "g"
        ], 
        "declaration": "snd-compose(f, g)", 
        "name": "snd-compose"
    }, 
    "snd-down": {
        "description": "Linear interpolation of samples down to the given sample rate srate, which must be lower than the sample rate of sound. Do not call this function. Nyquist performs sample-rate conversion automatically as needed. If you want to force a conversion, call force-srate (see Section \"Sound Synthesis\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-down", 
            "srate", 
            "sound"
        ], 
        "declaration": "snd-down(srate, sound)", 
        "name": "snd-down"
    }, 
    "patternp": {
        "description": "Test if expression is an Xmusic pattern.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "patternp", 
            "expression"
        ], 
        "declaration": "patternp(expression)", 
        "name": "patternp"
    }, 
    "get-loud": {
        "description": "Gets the current value of the *loud* environment variable. If *loud* is a signal, it is evaluated at local time 0 and a number (FLONUM) is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-loud"
        ], 
        "declaration": "get-loud()", 
        "name": "get-loud"
    }, 
    "string-right-trim": {
        "description": "bag - a string containing characters to trim, str - the string to trim, returns - a trimed copy of the string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "string-right-trim", 
            "bag", 
            "str"
        ], 
        "declaration": "string-right-trim(bag, str)", 
        "name": "string-right-trim"
    }, 
    "make-eval": {
        "description": "Evaluate expr to generate each item. If expr is a pattern, each item is generated by getting the next item from expr and evaluating it.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-eval", 
            "expr", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-eval(expr, for: for, name: name, trace: trace)", 
        "name": "make-eval"
    }, 
    "restore": {
        "description": "fname - the filename string or symbol, returns - nil on failure, otherwise never returns", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "restore", 
            "fname"
        ], 
        "declaration": "restore(fname)", 
        "name": "restore"
    }, 
    "score-read-smf": {
        "description": "Read a standard MIDI file from filename. Return an Xmusic score, or nil if the file could not be opened. The start time is zero, and the end time is the maximum end time of all notes. A very limited interface is offered to extract MIDI program numbers from the file: The global variable *rslt* is set to a list of MIDI program numbers for each channel. E.g. if *rslt* is (0 20 77), then program for channel 0 is 0, for channel 1 is 20, and for channel 2 is 77. Program changes were not found on other channels. The default program number is 0, so in this example, it is not known whether the program 0 on channel 0 is the result of a real MIDI program change command or just a default value. If more than one program change exists on a channel, the last program number is recorded and returned, so this information will only be completely correct when the MIDI file sends single program change per channel before any notes are played. This, however, is a fairly common practice. Note that the list returned as *rslt* can be passed to score-write-smf, described below.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-read-smf", 
            "filename"
        ], 
        "declaration": "score-read-smf(filename)", 
        "name": "score-read-smf"
    }, 
    "*rslt*": {
        "description": "When a function returns more than one value, *rslt* is set to a list of the \"extra\" values. This provides a make-shift version of the multiple-value-return facility in Common Lisp.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*rslt*"
        ], 
        "declaration": "*rslt*", 
        "name": "*rslt*"
    }, 
    "rest": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "rest", 
            "expr"
        ], 
        "declaration": "rest(expr)", 
        "name": "rest"
    }, 
    "*table*": {
        "description": "Default table used by osc and other oscillators.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*table*"
        ], 
        "declaration": "*table*", 
        "name": "*table*"
    }, 
    "dolist": {
        "description": "sym - the symbol to bind to each list element, expr - the list expression, rexpr - the result expression (the default is nil), expr - the body of the loop (treated like an implicit prog)", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "dolist", 
            "sym", 
            "expr", 
            "[", 
            "rexpr", 
            "]", 
            "expr..."
        ], 
        "declaration": "(dolist (sym expr [rexpr]) expr...)", 
        "name": "dolist"
    }, 
    "shape": {
        "description": "A waveshaping function. Use table as a function; apply the function to each sample of signal to yield a new sound. Signal should range from -1 to +1. Anything beyond these bounds is clipped. Table is also a sound, but it is converted into a lookup table (similar to table-lookup oscillators). The origin is a FLONUM and gives the time which should be considered the origin of table. (This is important because table cannot have values at negative times, but signal will often have negative values. The origin gives an offset so that you can produce suitable tables.) The output at time t is: table(origin + clip(signal(t)), where clip(x) = max(1, min(-1, x)). (E.g. if table is a signal defined over the interval [0, 2], then origin should be 1.0. The value of table at time 1.0 will be output when the input signal is zero.) The output has the same start time, sample rate, etc. as signal. The shape function will also accept multichannel signals and tables.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "shape", 
            "signal", 
            "table", 
            "origin"
        ], 
        "declaration": "shape(signal, table, origin)", 
        "name": "shape"
    }, 
    "snd-flute": {
        "description": "A flute implemented in STK. The freq is a FLONUM in Hertz, breath-env is a SOUND that ranges from zero to one, and sr is the desired sample rate (a FLONUM). You should use flute instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-flute", 
            "freq", 
            "breath-env", 
            "sr"
        ], 
        "declaration": "snd-flute(freq, breath-env, sr)", 
        "name": "snd-flute"
    }, 
    "fmfb": {
        "description": "Returns a sound generated by feedback FM synthesis. The pitch parameter (given in the usual half-step units) controls the fundamental frequency. The index is the amount of feedback, which may be a SOUND or a FLONUM. If index is a FLONUM, dur must be provided (a FLONUM) to specify the duration. Otherwise, dur is ignored if present and the duration is determined by that of index. The sample rate is *sound-srate*. A sinusoid table is used. If index is below 1.1, this generates a sawtooth-like waveform.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "fmfb", 
            "pitch", 
            "index", 
            "[", 
            "dur", 
            "]"
        ], 
        "declaration": "fmfb(pitch, index [, dur])", 
        "name": "fmfb"
    }, 
    "widen": {
        "description": "Artificially widen the stereo field in snd, a two-channel sound. The amount of widening is amt, which varies from 0 (snd is unchanged) to 1 (maximum widening). The amt can be a SOUND or a number.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "widen", 
            "snd", 
            "amt"
        ], 
        "declaration": "widen(snd, amt)", 
        "name": "widen"
    }, 
    "snd-sax": {
        "description": "A sax model implemented in STK. The freq is a FLONUM in Hertz, breath-env is a SOUND that ranges from zero to one, and sr is the desired sample rate (a FLONUM). You should use sax instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sax", 
            "freq", 
            "breath-env", 
            "sr"
        ], 
        "declaration": "snd-sax(freq, breath-env, sr)", 
        "name": "snd-sax"
    }, 
    "osc-note": {
        "description": "Same as osc, but osc-note multiplies the result by env. The env may be a sound, or a list supplying (t1 t2 t4 l1 l2 l3). The result has a sample rate of *sound-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "osc-note", 
            "pitch", 
            "[", 
            "duration", 
            "env", 
            "loud", 
            "table", 
            "]"
        ], 
        "declaration": "osc-note(pitch [, duration, env, loud, table])", 
        "name": "osc-note"
    }, 
    "mandolin": {
        "description": "A physical model of a plucked double-string instrument from STK. The step parameter is a FLONUM wich specifies the desired pitch, dur means the duration of the resulting sound and detune is a FLONUM that controls the relative detune of the two strings. A value of 1.0 means unison. The default value is 4.0. Note: body-size (see snd-mandolin does not seem to work correctly, so a default value is always used by mandolin.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "mandolin", 
            "step", 
            "dur", 
            "optional", 
            "detune"
        ], 
        "declaration": "mandolin(step, dur, optional detune)", 
        "name": "mandolin"
    }, 
    "s-add-to": {
        "description": "Evaluates the expression, which should result in a sound or an array of sounds, and adds the result to the given filename. The global *default-sf-dir* applies. A FLONUM is returned, giving the maximum absolute value of all samples written. The sample rate(s) of expression must match those of the file. The maximum number of samples written per channel is given by maxlen, which allows writing the initial part of a very long or infinite sound. If offset is specified, the new sound is added to the file beginning at an offset from the beginning (in seconds). The file is extended if necessary to accommodate the new addition, but if offset falls outside of the original file, the file is not modified. (If necessary, use s-add-to to extend the file with zeros.) The file must be a recognized sound file with a header (not a raw sound file).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-add-to", 
            "expression", 
            "maxlen", 
            "filename", 
            "[", 
            "offset", 
            "]"
        ], 
        "declaration": "s-add-to(expression, maxlen, filename [, offset])", 
        "name": "s-add-to"
    }, 
    "score-apply": {
        "description": "Replace each note in the score with the result of (function time dur expression) (in Lisp) or function(time, dur, expression) (in SAL), where time, dur, and expression are the time, duration, and expression of the note. If a range is indicated, only notes in the range are replaced. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-apply", 
            "score", 
            "function", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-apply(score, function, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-apply"
    }, 
    "sustain-abs": {
        "description": "Evaluates beh with *sustain* set to factor. (See sustain, above.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sustain-abs", 
            "factor", 
            "beh"
        ], 
        "declaration": "sustain-abs(factor, beh)", 
        "name": "sustain-abs"
    }, 
    "cue": {
        "description": "Applies *loud*, the starting time from *warp*, *start*, and *stop* to sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cue", 
            "sound"
        ], 
        "declaration": "cue(sound)", 
        "name": "cue"
    }, 
    "snd-shape": {
        "description": "A waveshaping function. This is the primitive upon which shape is based. The snd-shape function is like shape except that signal and table must be (single-channel) sounds. Use shape instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-shape", 
            "signal", 
            "table", 
            "origin"
        ], 
        "declaration": "snd-shape(signal, table, origin)", 
        "name": "snd-shape"
    }, 
    "fmlfo": {
        "description": "A low-frequency oscillator that computes at the *control-srate* using a sound to specify a time-varying frequency in Hz. Phase is a FLONUM in degrees. The duration of the result is determined by freq.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "fmlfo", 
            "freq", 
            "[", 
            "table", 
            "phase", 
            "]"
        ], 
        "declaration": "fmlfo(freq [, table, phase])", 
        "name": "fmlfo"
    }, 
    "snd-print-tree": {
        "description": "Prints an ascii representation of the internal data structures representing a sound. This is useful for debugging Nyquist. This function is safe for ordinary use.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-print-tree", 
            "sound"
        ], 
        "declaration": "snd-print-tree(sound)", 
        "name": "snd-print-tree"
    }, 
    "sampler": {
        "description": "Returns a sound constructed by reading a sample from beginning to end and then splicing on copies of the same sound from a loop point to the end. The pitch and modulation parameters are used as in fmosc described above. The optional sample (which defaults to the global variable *table* is a list of the form (sound pitch-number loop-start), where the first element is a sound containing the sample, the second is the pitch of the sample, and the third element is the time of the loop point. If the loop point is not in the bounds of the sound, it is set to zero. The optional npoints specifies how many points should be used for sample interpolation. Currently this parameter defaults to 2 and only 2-point (linear) interpolation is implemented. It is an error to modulate such that the frequency is negative. Note also that the loop point may be fractional. The sample rate is *sound-srate*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sampler", 
            "pitch", 
            "modulation", 
            "[", 
            "sample", 
            "npoints", 
            "]"
        ], 
        "declaration": "sampler(pitch, modulation [, sample, npoints])", 
        "name": "sampler"
    }, 
    "pwlv": {
        "description": "Creates a piece-wise linear envelope with breakpoints at (0, l1), (t2, l2), etc., ending with (tn, ln. Otherwise, the behavior is like that of pwl.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwlv", 
            "l1", 
            "t2", 
            "l2", 
            "t3", 
            "t3", 
            "...", 
            "tn", 
            "ln"
        ], 
        "declaration": "pwlv(l1, t2, l2, t3, t3, ... tn, ln)", 
        "name": "pwlv"
    }, 
    "save": {
        "description": "fname - the filename string or symbol, returns - t if workspace was written, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "save", 
            "fname"
        ], 
        "declaration": "save(fname)", 
        "name": "save"
    }, 
    "pwlr": {
        "description": "Creates a piece-wise linear envelope with breakpoints at (0, 0), (t1, l1), (t2, l2), ... (tn, 0), where tj is the sum of i1 through ij. In other words, the breakpoint times are specified in terms of intervals rather than cummulative time. Otherwise, the behavior is like that of pwl.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwlr", 
            "i1", 
            "l1", 
            "i2", 
            "l2", 
            "...", 
            "in"
        ], 
        "declaration": "pwlr(i1, l1, i2, l2, ... in)", 
        "name": "pwlr"
    }, 
    "gaussian-dist": {
        "description": "Returns a FLONUM value from the Gaussian or Gauss-Laplace distribution, a linear function of the normal distribution. It is symetric about the mean of xmu, with a standard deviation of sigma, which must be greater than zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "gaussian-dist", 
            "xmu", 
            "sigma", 
            "[", 
            "low", 
            "high", 
            "]"
        ], 
        "declaration": "gaussian-dist(xmu, sigma [, low, high])", 
        "name": "gaussian-dist"
    }, 
    "format": {
        "description": "stream - the output stream, fmt - the format string, arg - the format arguments, returns - output string if stream is nil, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "format", 
            "stream", 
            "fmt", 
            "arg..."
        ], 
        "declaration": "format(stream, fmt, arg...)", 
        "name": "format"
    }, 
    "read": {
        "description": "stream - the input stream (default is standard input), eof - the value to return on end of file (default is nil), rflag - recursive read flag (default is nil), returns - the expression read", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "read", 
            "[", 
            "stream", 
            "[", 
            "eof", 
            "[", 
            "rflag", 
            "]", 
            "]", 
            "]"
        ], 
        "declaration": "read([stream [, eof [, rflag]]])", 
        "name": "read"
    }, 
    "snd-quantize": {
        "description": "Quantizes a sound. See Section \"More Behaviors\" for details.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-quantize", 
            "sound", 
            "steps"
        ], 
        "declaration": "snd-quantize(sound, steps)", 
        "name": "snd-quantize"
    }, 
    "rplaca": {
        "description": "list - the list node, expr - the new value for the car of the list node, returns - the list node after updating the car", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "rplaca", 
            "list", 
            "expr"
        ], 
        "declaration": "rplaca(list, expr)", 
        "name": "rplaca"
    }, 
    "rplacd": {
        "description": "list - the list node, expr - the new value for the cdr of the list node, returns - the list node after updating the cdr", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "rplacd", 
            "list", 
            "expr"
        ], 
        "declaration": "rplacd(list, expr)", 
        "name": "rplacd"
    }, 
    "apply-banded-treble-boost": {
        "description": "Applies a boost to high frequencies. Separates input SOUND s into FIXNUM num-bands bands from a low frequency of lowp to a high frequency of highp (these are FLONUMS that specify steps, not Hz), and scales the highest num-boost (a FIXNUM) bands by gain, a FLONUM. The bands are summed to form the result, a SOUND.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "apply-banded-treble-boost", 
            "s", 
            "lowp", 
            "highp", 
            "num-bands", 
            "num-boost", 
            "gain"
        ], 
        "declaration": "apply-banded-treble-boost(s, lowp, highp, num-bands, num-boost, gain)", 
        "name": "apply-banded-treble-boost"
    }, 
    "snd-yin": {
        "description": "Identical to yin. See Section \"More Behaviors\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-yin", 
            "sound", 
            "minstep", 
            "maxstep", 
            "rate"
        ], 
        "declaration": "snd-yin(sound, minstep, maxstep, rate)", 
        "name": "snd-yin"
    }, 
    "pl-doppler": {
        "description": "Pitch-shift moving sounds according to the equation: fr = f0((c+vr)/c), where fr is the output frequency, f0 is the emitted (source) frequency, c is the speed of sound (assumed to be 344.31 m/s), and vr is the speed at which the emitter approaches the receiver. (vr is the first derivative of parameter r, the distance from the listener in meters.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pl-doppler", 
            "snd", 
            "r"
        ], 
        "declaration": "pl-doppler(snd, r)", 
        "name": "pl-doppler"
    }, 
    "intersection": {
        "description": "Compute the set intersection of lists a and b.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "intersection", 
            "a", 
            "b"
        ], 
        "declaration": "intersection(a, b)", 
        "name": "intersection"
    }, 
    "char-lessp": {
        "description": "chr1 - the first string to compare, chr2 - the second string(s) to compare, returns - t if predicate is true, nil otherwise, Note: case is not significant with these comparison functions.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "char-lessp", 
            "chr1", 
            "chr2..."
        ], 
        "declaration": "char-lessp(chr1, chr2...)", 
        "name": "char-lessp"
    }, 
    "funcall": {
        "description": "fun - the function to call (or function symbol), arg - arguments to pass to the function, returns - the result of calling the function with the arguments", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "funcall", 
            "fun", 
            "arg..."
        ], 
        "declaration": "funcall(fun, arg...)", 
        "name": "funcall"
    }, 
    "logand": {
        "description": "expr - the numbers, returns - the result of the and operation", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "logand", 
            "expr..."
        ], 
        "declaration": "logand(expr...)", 
        "name": "logand"
    }, 
    "chorus": {
        "description": "A chorus effect applied to snd. All parameters may be arrays as usual. The maxdepth is a FLONUM giving twice the maximum value of depth, which may be a FLONUM or a SOUND. The chorus is implemented as a variable delay modulated by a sinusoid running at rate Hz (a FLONUM). The sinusoid is scaled by depth and offset by maxdepth/2. The delayed signal is mixed with the original, and saturation gives the fraction of the delayed signal (from 0 to 1) in the mix. A reasonable choice of parameter values is maxdepth = 0.05, depth = 0.025, rate = 0.5, and saturation = 0.5.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "chorus", 
            "snd", 
            "maxdepth", 
            "depth", 
            "rate", 
            "saturation"
        ], 
        "declaration": "chorus(snd, maxdepth, depth, rate, saturation)", 
        "name": "chorus"
    }, 
    "continue": {
        "description": "returns - never returns", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "continue"
        ], 
        "declaration": "(continue)", 
        "name": "continue"
    }, 
    "s-save": {
        "description": "Evaluates the expression, which should result in a sound or an array of sounds, and writes the result to the given filename. A FLONUM is returned giving the maximum absolute value of all samples written. (This is useful for normalizing sounds and detecting sample overflow.) If play is not NIL, the sound will be output through the computer's audio output system. (play: [SAL]", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-save", 
            "expression", 
            "maxlen", 
            "filename", 
            "format:", 
            "format", 
            "mode:", 
            "mode", 
            "bits:", 
            "bits", 
            "swap:", 
            "flag", 
            "play:", 
            "play"
        ], 
        "declaration": "s-save(expression, maxlen,filename, format: format, mode: mode, bits: bits, swap: flag, play: play)", 
        "name": "s-save"
    }, 
    "snd-lpanal": {
        "description": "Compute an LPC frame with npoles (a FIXNUM) poles from an ARRAY of samples (FLONUMS). Note that snd-fetch-array can be used to fetch a sequence of frames from a sound. Ordinarily, you should not use this function. Use make-lpanal-iterator instead.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-lpanal", 
            "samps", 
            "npoles"
        ], 
        "declaration": "snd-lpanal(samps, npoles)", 
        "name": "snd-lpanal"
    }, 
    "get-transpose": {
        "description": "Gets the current value of the *transpose* environment variable. If *transpose* is a signal, it is evaluated at local time 0 and a number (FLONUM) is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-transpose"
        ], 
        "declaration": "get-transpose()", 
        "name": "get-transpose"
    }, 
    "get-temp-path": {
        "description": "returns - the resulting full path as a string", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-temp-path"
        ], 
        "declaration": "get-temp-path()", 
        "name": "get-temp-path"
    }, 
    "cauchy-dist": {
        "description": "Returns a FLONUM from the Cauchy distribution, a symetric distribution with a high peak at zero and a width (variance) that increases with parameter tau, which must be greater than zero. The low and high parameters give optional artificial bounds on the minimum and maximum output values, respectively.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cauchy-dist", 
            "tau", 
            "[", 
            "low", 
            "high", 
            "]"
        ], 
        "declaration": "cauchy-dist(tau [, low, high])", 
        "name": "cauchy-dist"
    }, 
    "type-of": {
        "description": "expr - the expression to return the type of, returns - nil if the value is nil otherwise one of the symbols:, SYMBOL - for symbols, OBJECT - for objects, CONS - for conses, SUBR - for built-in functions, FSUBR - for special forms, CLOSURE - for defined functions, STRING - for strings, FIXNUM - for integers, FLONUM - for floating point numbers, CHARACTER - for characters, FILE-STREAM - for file pointers, UNNAMED-STREAM - for unnamed streams, ARRAY - for arrays", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "type-of", 
            "expr"
        ], 
        "declaration": "type-of(expr)", 
        "name": "type-of"
    }, 
    "snd-bandedwg": {
        "description": "A Banded Wave Guide Percussion instrument implemented in STK. The parameter freq is a FLONUM in Hz, bowpress-env is a SOUND that ranges from zero to one, preset is a FIXNUM, and sr is the desired sample rate in Hz. Currently, there are four presets: uniform-bar (0), tuned-bar (1), glass-harmonica (2), and tibetan-bowl (3). You should use wg-uniform-bar, wg-tuned-bar, wg-glass-harm, or wg-tibetan-bowl instead (see Section \"Physical Models\").", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "snd-bandedwg", 
            "freq", 
            "bowpress-env", 
            "preset", 
            "sr", 
            "snd-bandedwg", 
            "freq", 
            "bowpress-env", 
            "preset", 
            "sr"
        ], 
        "declaration": "(snd-bandedwg freq bowpress-env preset sr), (snd-bandedwg freq bowpress-env preset sr)", 
        "name": "snd-bandedwg"
    }, 
    "both-case-p": {
        "description": "chr - the character, returns - t if the character is alphabetic, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "both-case-p", 
            "chr"
        ], 
        "declaration": "both-case-p(chr)", 
        "name": "both-case-p"
    }, 
    "intern": {
        "description": "pname - the symbol's print name string, returns - the new symbol", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "intern", 
            "pname"
        ], 
        "declaration": "intern(pname)", 
        "name": "intern"
    }, 
    "*autonorm-previous-peak*": {
        "description": "The peak of the previous sound generated by play. This is used to compute the scale factor for the next sound when *autonorm-type* is 'previous. See Sections \"Memory Space and Normalization\" and \"Sound File Input and Output\".", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*autonorm-previous-peak*"
        ], 
        "declaration": "*autonorm-previous-peak*", 
        "name": "*autonorm-previous-peak*"
    }, 
    "score-set-end": {
        "description": "The end time from the score's SCORE-BEGIN-END marker is set to time. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-set-end", 
            "score", 
            "time"
        ], 
        "declaration": "score-set-end(score, time)", 
        "name": "score-set-end"
    }, 
    "*clipping-threshold*": {
        "description": "See *clipping-error* for a description of this variable. *clipping-threshold* is initialized to 127/128. This number is conservative, and it is possible to slightly exceed this value, even with 8-bit files without actual clipping (consider rounding. Also, floating point format files will not clip even when the amplitude exceeds 1.0. Note that a \"clipping\" threshold of 1.0 is optimistic: 1.0 corresponds to a 16-bit integer value of 32,768 (2^15), but the maximum positive 16-bit integer is 32,767. Thus, a positive sample of 1.0 will clip when written or played as 16-bit audio.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*clipping-threshold*"
        ], 
        "declaration": "*clipping-threshold*", 
        "name": "*clipping-threshold*"
    }, 
    "*file-separator*": {
        "description": "The character that separates directories in a path, e.g. \"/\" for Unix, \":\" for Mac, and \"\\\" for Win32. This is normally set in system.lsp.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*file-separator*"
        ], 
        "declaration": "*file-separator*", 
        "name": "*file-separator*"
    }, 
    "scale-srate": {
        "description": "Scales the sample rate of sound by scale factor. This has the effect of linearly shrinking or stretching time (the sound is not upsampled or downsampled). This is a special case of snd-xform (see Section \"Signal Operations\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "scale-srate", 
            "sound", 
            "scale"
        ], 
        "declaration": "scale-srate(sound, scale)", 
        "name": "scale-srate"
    }, 
    "feedback-delay": {
        "description": "Applies feedback delay to sound. The delay must be a number (in seconds). It is rounded to the nearest sample to determine the length of the delay. The sample rate is the maximum from sound and feedback (if feedback is also a sound). The amound of feedback should be less than one to avoid an exponential increase in amplitude. The start time and stop time, and logical stop time are taken from sound. Since output is truncated at the stop time of sound, you may want to append some silence to sound to give the filter time to decay.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "feedback-delay", 
            "sound", 
            "delay", 
            "feedback"
        ], 
        "declaration": "feedback-delay(sound, delay, feedback)", 
        "name": "feedback-delay"
    }, 
    "s-print-tree": {
        "description": "Prints an ascii representation of the internal data structures representing a sound. This is useful for debugging Nyquist. Identical to snd-print-tree.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-print-tree", 
            "sound"
        ], 
        "declaration": "s-print-tree(sound)", 
        "name": "s-print-tree"
    }, 
    "echoenabled": {
        "description": "flag - T to enable echo, NIL to disable, returns - NIL, Note: This function is only implemented under Linux and Mac OS X. If Nyquist I/O is redirected through pipes, the Windows version does not echo the input, but the Linux and Mac versions do. You can turn off echoing with this function. Under windows it is defined to do nothing.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "echoenabled", 
            "flag"
        ], 
        "declaration": "echoenabled(flag)", 
        "name": "echoenabled"
    }, 
    "score-stretch": {
        "description": "Stretch note times and durations by factor. The default dur-flag is non-null, but if dur-flag is null, the original durations are retained and only times are stretched. Similarly, the default time-flag is non-null, but if time-flag is null, the original times are retained and only durations are stretched. If both dur-flag and time-flag are null, the score is not changed. If a range of notes is specified, times are scaled within that range, and notes after the range are shifted so that the stretched region does not create a \"hole\" or overlap with notes that follow. If the range begins or ends with a time (via from-time: and to-time:), time stretching takes place over the indicated time interval independent of whether any notes are present or where they start. In other words, the \"rests\" are stretched along with the notes. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-stretch", 
            "score", 
            "factor", 
            "dur:", 
            "dur-flag", 
            "time:", 
            "time-flag", 
            "from-index:", 
            "i", 
            "to-index:", 
            "j", 
            "from-time:", 
            "x", 
            "to-time:", 
            "y"
        ], 
        "declaration": "score-stretch(score, factor, dur: dur-flag, time: time-flag, from-index: i, to-index: j, from-time: x, to-time: y)", 
        "name": "score-stretch"
    }, 
    "prologic": {
        "description": "Encode four monaural SOUNDs representing the front-left, front-center, front-right, and rear channels, respectively. The return value is a stereo sound, which is a Dolby-encoded mix of the four input sounds.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "prologic", 
            "l", 
            "c", 
            "r", 
            "s"
        ], 
        "declaration": "prologic(l, c, r, s)", 
        "name": "prologic"
    }, 
    "/": {
        "description": "expr - the numbers, returns - the result of the division", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "/", 
            "expr..."
        ], 
        "declaration": "(/ expr...)", 
        "name": "/"
    }, 
    "exit": {
        "description": "returns - never returns", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "exit"
        ], 
        "declaration": "exit()", 
        "name": "exit"
    }, 
    "score-filter-overlap": {
        "description": "Remove overlapping notes (based on the note start time and duration), giving priority to the positional order within the note list (which is also time order). The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-filter-overlap", 
            "score"
        ], 
        "declaration": "score-filter-overlap(score)", 
        "name": "score-filter-overlap"
    }, 
    "prog": {
        "description": "binding - the variable bindings each of which is either:, 1) a symbol (which is initialized to nil), 2) a list whose car is a symbol and whose cadr is an initialization expression expr - expressions to evaluate or tags (symbols), returns - nil or the argument passed to the return function", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "prog", 
            "binding...", 
            "expr..."
        ], 
        "declaration": "(prog (binding...) expr...)", 
        "name": "prog"
    }, 
    "snd-scale": {
        "description": "Scales the amplitude of sound by the factor scale. Use scale instead (see Section \"Sound Synthesis\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-scale", 
            "scale", 
            "sound"
        ], 
        "declaration": "snd-scale(scale, sound)", 
        "name": "snd-scale"
    }, 
    "prod": {
        "description": "Same as mult.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "prod", 
            "beh1", 
            "beh2", 
            "..."
        ], 
        "declaration": "prod(beh1, beh2, ...)", 
        "name": "prod"
    }, 
    "pwlvr-list": {
        "description": "A version of pwlvr that takes a single list of breakpoints as its argument. See pwl-list above for the rationale.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwlvr-list", 
            "breakpoints"
        ], 
        "declaration": "pwlvr-list(breakpoints)", 
        "name": "pwlvr-list"
    }, 
    "make-accumulate": {
        "description": "Keep a running sum of numbers generated by sub-pattern. The default period lengths match the period lengths from sub-pattern. If maximum (a pattern or a number) is specified, and the running sum exceeds maximum, the running sum is reset to maximum. If minimum (a pattern or a number) is specified, and the running sum falls below minimum, the running sum is reset to minimum. If minimum is greater than maximum, the running sum will be set to one of the two values. Note that this is similar in name but not in function to make-accumulation.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-accumulate", 
            "sub-pattern", 
            "for:", 
            "for", 
            "max:", 
            "maximum", 
            "min:", 
            "minimum", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-accumulate(sub-pattern, for: for, max: maximum, min: minimum, name: name, trace: trace)", 
        "name": "make-accumulate"
    }, 
    "peek": {
        "description": "addrs - the address to peek at (integer), returns - the value at the specified address (integer)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "peek", 
            "addrs"
        ], 
        "declaration": "peek(addrs)", 
        "name": "peek"
    }, 
    "noise": {
        "description": "Generate noise with the given duration. Duration (default is 1.0) is transformed according to *warp*. The sample rate is *sound-srate* and the amplitude is +/- *loud*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "noise", 
            "[", 
            "duration", 
            "]"
        ], 
        "declaration": "noise([duration])", 
        "name": "noise"
    }, 
    "snd-trigger": {
        "description": "This is one of the only ways in which a behavior instance can be created by changes in a signal. When s (a SOUND) makes a transition from less than or equal to zero to greater than zero, the closure, which takes a starting time parameter, is evaluated. The closure must return a SOUND. The sum of all these sounds is returned. If there are no sounds, the result will be zero. The stop time of the result is the maximum stop time of s and all sounds returned by the closure. The sample rate of the return value is the sample rate of s, and the sounds returned by the closure must all have that same sample rate. Do not call this function. See trigger in Section \"Combination and Time Structure\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-trigger", 
            "s", 
            "closure"
        ], 
        "declaration": "snd-trigger(s, closure)", 
        "name": "snd-trigger"
    }, 
    "power": {
        "description": "Returns x raised to the y power.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "power", 
            "x", 
            "y"
        ], 
        "declaration": "power(x, y)", 
        "name": "power"
    }, 
    "snd-slider": {
        "description": "Create a sound controlled by the slider named by index (an integer index into the array of sliders; see get-slider-value for more information). The function returns a sound. Since Nyquist sounds are computed in blocks of samples, and each block is computed at once, each block will contain copies of the current slider value. To obtain reasonable responsiveness, slider sounds should have high (audio) sample rates so that the block rate will be reasonably high. Also, consider lowering the audio latency using snd-set-latency. To \"trigger\" a Nyquist behavior using slider input, see the trigger function in Section \"Combination and Time Structure\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-slider", 
            "index", 
            "t0", 
            "srate", 
            "duration"
        ], 
        "declaration": "snd-slider(index, t0, srate, duration)", 
        "name": "snd-slider"
    }, 
    "snd-from-array": {
        "description": "See \"Accessing and Creating Sound\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-from-array", 
            "..."
        ], 
        "declaration": "(snd-from-array ...)", 
        "name": "snd-from-array"
    }, 
    "arrayp": {
        "description": "expr - the expression to check, returns - t if the value is an array, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "arrayp", 
            "expr"
        ], 
        "declaration": "arrayp(expr)", 
        "name": "arrayp"
    }, 
    "snd-aresonvc": {
        "description": "This function is identical to snd-areson except the hz (center frequency) parameter is a sound. Filter coefficients are updated at the sample rate of hz. You should use areson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-aresonvc", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-aresonvc(sound, hz, bw,normalization)", 
        "name": "snd-aresonvc"
    }, 
    "midi-show": {
        "description": "Print the contents of the sequence the-seq to the file out-file (whose default value is the console.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "midi-show", 
            "the-seq", 
            "[", 
            "out-file", 
            "]"
        ], 
        "declaration": "midi-show(the-seq [, out-file])", 
        "name": "midi-show"
    }, 
    "binomial-dist": {
        "description": "Returns a FIXNUM value from the binomial distribution, where n is the number of Bernoulli trials run (a FIXNUM) and p is the probability of success in the Bernoulli trial (a FLONUM from 0 to 1). The mean is the product of n and p.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "binomial-dist", 
            "n", 
            "p"
        ], 
        "declaration": "binomial-dist(n, p)", 
        "name": "binomial-dist"
    }, 
    "symbol-function": {
        "description": "sym - the symbol, returns - the symbol's functional value", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "symbol-function", 
            "sym"
        ], 
        "declaration": "symbol-function(sym)", 
        "name": "symbol-function"
    }, 
    "digit-char-p": {
        "description": "chr - the character, returns - the digit weight if character is a digit, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "digit-char-p", 
            "chr"
        ], 
        "declaration": "digit-char-p(chr)", 
        "name": "digit-char-p"
    }, 
    "snd-aresonvv": {
        "description": "This function is identical to snd-areson except both hz (center frequency) and bw (bandwidth) are sounds. Filter coefficients are updated at the next sample of either hz or bw. You should use areson instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-aresonvv", 
            "sound", 
            "hz", 
            "bw", 
            "normalization"
        ], 
        "declaration": "snd-aresonvv(sound, hz, bw,normalization)", 
        "name": "snd-aresonvv"
    }, 
    "sound-on": {
        "description": "Enable real-time audio output when sound is computed by the the play command.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sound-on"
        ], 
        "declaration": "sound-on()", 
        "name": "sound-on"
    }, 
    "s-sqrt": {
        "description": "A generalized square root function. If sound is a SOUND, compute the square root of each sample. If sound is a number, just compute the square root. If sound is a multichannel sound, return a multichannel sound with s-sqrt applied to each element. The result has the type, sample rate, starting time, etc. of sound. In taking square roots, if an input sample is less than zero, the corresponding output sample is zero. This is done because the square root of a negative number is undefined.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-sqrt", 
            "sound"
        ], 
        "declaration": "s-sqrt(sound)", 
        "name": "s-sqrt"
    }, 
    "snd-fromobject": {
        "description": "Creates a sound for which samples come from object. The starting time is t0 (a FLONUM), and the sample rate is sr. The object is an XLISP object (see Section \"Objects\" for information on objects. A sound is returned. When the sound needs samples, they are generated by sending the message :next to object. If object returns NIL, the sound terminates. Otherwise, object must return a FLONUM. There is no provision for object to specify the logical stop time of the sound, so the logical stop time is the termination time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-fromobject", 
            "t0", 
            "sr", 
            "object"
        ], 
        "declaration": "snd-fromobject(t0, sr, object)", 
        "name": "snd-fromobject"
    }, 
    "integerp": {
        "description": "expr - the expression to check, returns - t if the value is an integer, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "integerp", 
            "expr"
        ], 
        "declaration": "integerp(expr)", 
        "name": "integerp"
    }, 
    "nthcdr": {
        "description": "n - the number of the element to return (zero origin), list - the list, returns - the nth cdr or nil if the list isn't that long", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "nthcdr", 
            "n", 
            "list"
        ], 
        "declaration": "nthcdr(n, list)", 
        "name": "nthcdr"
    }, 
    "union": {
        "description": "Compute the set union of lists a and b.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "union", 
            "a", 
            "b"
        ], 
        "declaration": "union(a, b)", 
        "name": "union"
    }, 
    "unwind-protect": {
        "description": "expr - the expression to protect, cexpr - the cleanup expressions, returns - the value of the expression, Note: unwind-protect guarantees to execute the cleanup expressions even if a non-local exit terminates the evaluation of the protected expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "unwind-protect", 
            "expr", 
            "cexpr..."
        ], 
        "declaration": "unwind-protect(expr, cexpr...)", 
        "name": "unwind-protect"
    }, 
    "*control-srate*": {
        "description": "Part of the environment, establishes the control sample rate. See Section \"The Environment\" for details.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*control-srate*"
        ], 
        "declaration": "*control-srate*", 
        "name": "*control-srate*"
    }, 
    "flute-all": {
        "description": "A physical model of a bowed string instrument from STK. The step parameter is a FLONUM that controls the string length, and the bowpress-env controls the bow pressure and also determines the duration of the resulting sound. The bowpress-env signal should range from zero to one.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "flute-all", 
            "step", 
            "breath-env", 
            "freq-env", 
            "vibrato-freq", 
            "vibrato-gain", 
            "jet-delay", 
            "noise"
        ], 
        "declaration": "flute-all(step, breath-env, freq-env, vibrato-freq, vibrato-gain, jet-delay, noise)", 
        "name": "flute-all"
    }, 
    "allpoles-from-lpc": {
        "description": "A single LPC frame defines a filter. Use allpoles-from-lpc to apply this filter to snd, a SOUND. To obtain lpc-frame, a LIST containing an LPC frame, either send :next to an LPC iterator, or use nth-frame (see below). The result is a SOUND whose duration is the same as that of snd.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "allpoles-from-lpc", 
            "snd", 
            "lpc-frame"
        ], 
        "declaration": "allpoles-from-lpc(snd, lpc-frame)", 
        "name": "allpoles-from-lpc"
    }, 
    "snd-flute-all": {
        "description": "A flute model just like snd-flute-freq but with additional parameters for vibrato generation and continuous control of breath noise. You should use flute-all instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-flute-all", 
            "freq", 
            "vibrato-freq", 
            "vibrato-gain", 
            "freq-env", 
            "breath-env", 
            "jet-delay", 
            "noise", 
            "sr"
        ], 
        "declaration": "snd-flute-all(freq, vibrato-freq, vibrato-gain, freq-env, breath-env,jet-delay, noise, sr)", 
        "name": "snd-flute-all"
    }, 
    "or": {
        "description": "expr - the expressions to be ored, returns - nil if all expressions evaluate to nil, otherwise the value of the first non-nil expression (evaluation of expressions stops after the first expression that does not evaluate to nil)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "or", 
            "expr..."
        ], 
        "declaration": "or(expr...)", 
        "name": "or"
    }, 
    "block": {
        "description": "name - the block name (symbol), expr - the block body, returns - the value of the last expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "block", 
            "name", 
            "expr..."
        ], 
        "declaration": "block(name, expr...)", 
        "name": "block"
    }, 
    "loud-abs": {
        "description": "Evaluates beh with *loud* set to volume.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "loud-abs", 
            "volume", 
            "beh"
        ], 
        "declaration": "loud-abs(volume, beh)", 
        "name": "loud-abs"
    }, 
    "score-repeat": {
        "description": "Make a sequence of n copies of score. Each copy is shifted to that it's begin time aligns with the end time of the previous copy, as in score-append. The original score is not modified, and a new score is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-repeat", 
            "score", 
            "n"
        ], 
        "declaration": "score-repeat(score, n)", 
        "name": "score-repeat"
    }, 
    "float": {
        "description": "expr - the number, returns - the result of floating the integer", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "float", 
            "expr"
        ], 
        "declaration": "float(expr)", 
        "name": "float"
    }, 
    "snd-copy": {
        "description": "Makes a copy of sound. Since operators always make (logical) copies of their sound parameters, this function should never be needed. This function is here for debugging.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-copy", 
            "sound"
        ], 
        "declaration": "snd-copy(sound)", 
        "name": "snd-copy"
    }, 
    "make-string-output-stream": {
        "description": "returns - an unnamed output stream", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-string-output-stream"
        ], 
        "declaration": "make-string-output-stream)()", 
        "name": "make-string-output-stream"
    }, 
    "event-get-attr": {
        "description": "Get the value of the given attribute from a score event's expression. If attribute is not present, return default if specified, and otherwise nil.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-get-attr", 
            "event", 
            "attribute", 
            "[", 
            "default", 
            "]"
        ], 
        "declaration": "event-get-attr(event, attribute, [default])", 
        "name": "event-get-attr"
    }, 
    "snd-seq": {
        "description": "This function returns sound until the logical stop time of sound. Then, the XLISP closure is evaluated, passing it the logical stop time of sound as a parameter. The closure must return a sound, which is then added to sound. (An add is used so that sound can continue past its logical stop if desired.) Do not call this function. See seq in Section \"Combination and Time Structure\".", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-seq", 
            "sound", 
            "closure"
        ], 
        "declaration": "snd-seq(sound, closure)", 
        "name": "snd-seq"
    }, 
    "s-log": {
        "description": "A generalized natural log function. If sound is a SOUND, compute ln(x) for each sample x. If sound is a number x, just compute ln(x). If sound is a multichannel sound, return a multichannel sound with s-log applied to each element. The result has the type, sample rate, starting time, etc. of sound. Note that the ln of 0 is undefined (some implementations return negative infinity), so use this function with care.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "s-log", 
            "sound"
        ], 
        "declaration": "s-log(sound)", 
        "name": "s-log"
    }, 
    "aref": {
        "description": "array - the array, n - the array index (integer), returns - the value of the array element", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "aref", 
            "array", 
            "n"
        ], 
        "declaration": "aref(array, n)", 
        "name": "aref"
    }, 
    "span": {
        "description": "Pan the virtual center channel of a stereo sound, snd, by amt, where 0 pans all the way to the left, while 1 pans all the way to the right. The amt can be a SOUND or a number.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "span", 
            "snd", 
            "amt"
        ], 
        "declaration": "span(snd, amt)", 
        "name": "span"
    }, 
    "log": {
        "description": "Calculates the natural log of x (a FLONUM). (See s-log for a version that operates on signals.)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "log", 
            "x"
        ], 
        "declaration": "log(x)", 
        "name": "log"
    }, 
    "*": {
        "description": "expr - the numbers, returns - the result of the multiplication", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "*", 
            "expr..."
        ], 
        "declaration": "(* expr...)", 
        "name": "*"
    }, 
    "extract-abs": {
        "description": "Returns a sound which is the portion of beh between start and stop, independent of the current *warp*. The result is shifted to start according to *warp*.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "extract-abs", 
            "start", 
            "stop", 
            "beh"
        ], 
        "declaration": "extract-abs(start, stop, beh)", 
        "name": "extract-abs"
    }, 
    "subst": {
        "description": "to - the new expression, from - the old expression, expr - the expression in which to do the substitutions, :test - the test function (defaults to eql), :test-not - the test function (sense inverted) , returns - the expression with substitutions", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "subst", 
            "to", 
            "from", 
            "expr", 
            "test:", 
            "test", 
            "test-not:", 
            "test-not"
        ], 
        "declaration": "subst(to, from, expr, test: test, test-not: test-not)", 
        "name": "subst"
    }, 
    "dotimes": {
        "description": "sym - the symbol to bind to each value from 0 to n-1, expr - the number of times to loop, rexpr - the result expression (the default is nil), expr - the body of the loop (treated like an implicit prog)", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "dotimes", 
            "sym", 
            "expr", 
            "[", 
            "rexpr", 
            "]", 
            "expr..."
        ], 
        "declaration": "(dotimes (sym expr [rexpr]) expr...)", 
        "name": "dotimes"
    }, 
    "score-read": {
        "description": "Read an Adagio file from filename. Return an Xmusic score, or nil if the file could not be opened. See Chapter \"MIDI, Adagio, and Sequences\" for details on Adagio, a text-based score language. See score-read-smf for details on handling program changes.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "score-read", 
            "filename"
        ], 
        "declaration": "score-read(filename)", 
        "name": "score-read"
    }, 
    "event-set-attr": {
        "description": "Construct a new event identical to event except that the attribute has value.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-set-attr", 
            "event", 
            "attribute", 
            "value"
        ], 
        "declaration": "event-set-attr(event, attribute, value)", 
        "name": "event-set-attr"
    }, 
    "int-char": {
        "description": "int - the ascii character code, returns - the character with that code", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "int-char", 
            "int"
        ], 
        "declaration": "int-char(int)", 
        "name": "int-char"
    }, 
    "lambda": {
        "description": "args - formal argument list (lambda list) (quoted), expr - expressions of the function body, returns - the function closure", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lambda", 
            "args", 
            "expr..."
        ], 
        "declaration": "lambda(args, expr...)", 
        "name": "lambda"
    }, 
    "function": {
        "description": "expr - the symbol or lambda expression (quoted), returns - the functional interpretation", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "function", 
            "expr"
        ], 
        "declaration": "function(expr)", 
        "name": "function"
    }, 
    "piano-midi2file": {
        "description": "Use the piano synthesizer to play a MIDI file. The MIDI file is given by midi-file-name and the (monophonic) result is written to the file named sound-file-name.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "piano-midi2file", 
            "midi-file-name", 
            "sound-file-name"
        ], 
        "declaration": "piano-midi2file(midi-file-name, sound-file-name)", 
        "name": "piano-midi2file"
    }, 
    "filep": {
        "description": "expr - the expression to check, returns - t if the value is an object, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "filep", 
            "expr"
        ], 
        "declaration": "filep(expr)", 
        "name": "filep"
    }, 
    "add-action-to-workspace": {
        "description": "Requests that the function named by symbol be called when the workspace is loaded (if the function is defined).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "add-action-to-workspace", 
            "symbol"
        ], 
        "declaration": "add-action-to-workspace(symbol)", 
        "name": "add-action-to-workspace"
    }, 
    "event-dur": {
        "description": "Retrieve the duration (i.e. the stretch factor) field from an event.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-dur", 
            "event"
        ], 
        "declaration": "event-dur(event)", 
        "name": "event-dur"
    }, 
    "return-from": {
        "description": "name - the block name (symbol), value - the value to return (defaults to nil), returns - never returns", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "return-from", 
            "name", 
            "[", 
            "value", 
            "]"
        ], 
        "declaration": "return-from(name [, value])", 
        "name": "return-from"
    }, 
    "snd-xform": {
        "description": "Makes a copy of sound and then alters it in the following order: (1) the start time (snd-t0) of the sound is shifted to time, (1) the sound is stretched as a result of setting the sample rate to sr (the start time is unchanged by this), (3) the sound is clipped from start to stop, (4) if start is greater than time, the sound is shifted shifted by time - start, so that the start time is time, (5) the sound is scaled by scale. An empty (zero) sound at time will be returned if all samples are clipped. Normally, you should accomplish all this using transformations. A transformation applied to a sound has no effect, so use cue to create a transformable sound (see Section \"Using Previously Created Sounds\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-xform", 
            "sound", 
            "sr", 
            "time", 
            "start", 
            "stop", 
            "scale"
        ], 
        "declaration": "snd-xform(sound, sr, time, start,stop, scale)", 
        "name": "snd-xform"
    }, 
    "hp": {
        "description": "Filters sound using a first-order Butterworth high-pass filter. Cutoff may be a float or a signal (for time-varying filtering) and expresses hertz. Filter coefficients (requiring trig functions) are recomputed at the sample rate of cutoff. This filter is an exact complement of lp.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "hp", 
            "sound", 
            "cutoff"
        ], 
        "declaration": "hp(sound, cutoff)", 
        "name": "hp"
    }, 
    "siosc": {
        "description": "Returns a sound constructed by interpolating through a succession of periodic waveforms. The frequency is given (in half steps) by pitch to which a modulation signal (in hz) is added, exactly as in fmosc. The tables specify a list of waveforms as follows: (table0 time1 table2 ... timeN tableN), where each table is a sound representing one period. Each time is a time interval measured from the starting time. The time is scaled by the nominal duration (computed using (local-to-global (get-sustain))) to get the actual time. Note that this implies linear stretching rather than continuous timewarping of the interpolation or the breakpoints. The waveform is table0 at the starting time, table1 after time1 (scaled as described), and so on. The duration and logical stop time is given by modulation. If modulation is shorter than timeN, then the full sequence of waveforms is not used. If modulation is longer than timeN, tableN is used after timeN without further interpolation.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "siosc", 
            "pitch", 
            "modulation", 
            "tables"
        ], 
        "declaration": "siosc(pitch,modulation, tables)", 
        "name": "siosc"
    }, 
    "notch2": {
        "description": "A fixed-parameter, second-order notch filter based on snd-biquad. The center frequency is given by hz (a FLONUM) and an optional Q factor is given by q (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "notch2", 
            "signal", 
            "hz", 
            "[", 
            "q", 
            "]"
        ], 
        "declaration": "notch2(signal, hz [, q])", 
        "name": "notch2"
    }, 
    "remprop": {
        "description": "sym - the symbol, prop - the property symbol, returns - nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "remprop", 
            "sym", 
            "prop"
        ], 
        "declaration": "remprop(sym, prop)", 
        "name": "remprop"
    }, 
    "snd-allpoles": {
        "description": "A fixed all-pole filter. The input is snd, a SOUND. The filter coefficients are given by lpc-coefs (an ARRAY), and the filter gain is given by gain, a FLONUM. The result is a SOUND whose duration matches that of snd. Ordinarily, you should use allpoles-from-lpc instead (see above).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-allpoles", 
            "snd", 
            "lpc-coefs", 
            "gain"
        ], 
        "declaration": "snd-allpoles(snd, lpc-coefs, gain)", 
        "name": "snd-allpoles"
    }, 
    "pwe": {
        "description": "Creates a piece-wise exponential envelope with breakpoints at (0, 1), (t1, l1), (t2, l2), ... (tn, 1). Exponential segments means that the ratio of values from sample to sample is constant within the segment. (The current implementation actually takes the log of each value, computes a piece-wise exponential from the points using pwl, then exponentiates each resulting sample. A faster implementation is certainly possible!) Breakpoint values (lj) must be greater than zero. Otherwise, this function is similar to pwl, including stretch by *sustain*, mapping according to *warp*, sample rate based on *control-srate*, and \"breakpoint munging\" (see pwl described above). Default initial and final values are of dubious value with exponentials. See pwev below for the function you are probably looking for.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwe", 
            "t1", 
            "l1", 
            "t2", 
            "l2", 
            "...", 
            "tn"
        ], 
        "declaration": "pwe(t1, l1, t2, l2, ... tn)", 
        "name": "pwe"
    }, 
    "lpreson": {
        "description": "Implements a time-varying all-pole filter controlled by a sequence of LPC frames from an iterator. The SOUND to be filtered is snd, and the source of LPC frames is lpc-iterator, typically an instance of lpanal-class or lpc-file-class. The frame period (in seconds) is given by skiptime (a FLONUM). This number does not have to agree with the skiptime used to analyze the frames. (Greater values will cause the filter evolution slow down, and smaller values will cause it to speed up.) The result is a SOUND. The duration of the result is the minimum of the duration of snd and that of the sequence of frames.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "lpreson", 
            "snd", 
            "lpc-iterator", 
            "skiptime"
        ], 
        "declaration": "lpreson(snd, lpc-iterator, skiptime)", 
        "name": "lpreson"
    }, 
    "atom": {
        "description": "expr - the expression to check, returns - t if the value is an atom, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "atom", 
            "expr"
        ], 
        "declaration": "atom(expr)", 
        "name": "atom"
    }, 
    "pwl": {
        "description": "Creates a piece-wise linear envelope with breakpoints at (0, 0), (t1, l1), (t2, l2), ... (tn, 0). The breakpoint times are scaled linearly by the value of *sustain* (if *sustain* is a SOUND, it is evaluated once at the starting time of the envelope). Each breakpoint time is then mapped according to *warp*. The result is a linear interpolation (unwarped) between the breakpoints. The sample rate is *control-srate*. Breakpoint times are quantized to the nearest sample time. If you specify one or more breakpoints withing one sample period, pwl attempts to give a good approximation to the specified function. In particular, if two breakpoints are simultaneous, pwl will move one of them to an adjacent sample, producing a steepest possible step in the signal. The exact details of this \"breakpoint munging\" is subject to change in future versions. Please report any cases where breakpoint lists give unexpected behaviors. The author will try to apply the \"principle of least surprise\" to the design. Note that the times are relative to 0; they are not durations of each envelope segment.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwl", 
            "t1", 
            "l1", 
            "t2", 
            "l2", 
            "...", 
            "tn"
        ], 
        "declaration": "pwl(t1, l1, t2, l2, ... tn)", 
        "name": "pwl"
    }, 
    "compress-map": {
        "description": "Construct a map for the compress function. The map consists of two parts: a compression part and an expansion part. The intended use is to compress everything above compress-threshold by compress-ratio, and to downward expand everything below expand-ratio by expand-ratio. Thresholds are in dB and ratios are dB-per-dB. 0dB corresponds to a peak amplitude of 1.0 or rms amplitude of 0.7 If the input goes above 0dB, the output can optionally be limited by setting limit: (a keyword parameter) to T. This effectively changes the compression ratio to infinity at 0dB. If limit: is nil (the default), then the compression-ratio continues to apply above 0dB.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "compress-map", 
            "compress-ratio", 
            "compress-threshold", 
            "expand-ratio", 
            "expand-threshold", 
            "limit:", 
            "limit", 
            "transition:", 
            "transition"
        ], 
        "declaration": "compress-map(compress-ratio, compress-threshold, expand-ratio, expand-threshold, limit: limit, transition: transition)", 
        "name": "compress-map"
    }, 
    "info": {
        "description": "returns - nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "info"
        ], 
        "declaration": "info()", 
        "name": "info"
    }, 
    "*A4-Hertz*": {
        "description": "Frequency of A4 in Hertz.. Note: you must call (set-pitch-names) to recompute pitches after changing *A4-Hertz*.", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*A4-Hertz*"
        ], 
        "declaration": "*A4-Hertz*", 
        "name": "*A4-Hertz*"
    }, 
    "flatc": {
        "description": "expr - the expression, returns - the length", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "flatc", 
            "expr"
        ], 
        "declaration": "flatc(expr)", 
        "name": "flatc"
    }, 
    "symbol-name": {
        "description": "sym - the symbol, returns - the symbol's print name", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "symbol-name", 
            "sym"
        ], 
        "declaration": "symbol-name(sym)", 
        "name": "symbol-name"
    }, 
    "snd-alpassvv": {
        "description": "An all-pass filter with variable feedback and delay. This is just like snd-alpass except feedback and delay are sounds, and there is an additional FLONUM parameter, maxdelay, that gives an upper bound on the value of delay. Note: delay must remain between zero and maxdelay. If not, results are undefined, and Nyquist may crash. You should use alpass instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-alpassvv", 
            "sound", 
            "delay", 
            "feedback", 
            "maxdelay"
        ], 
        "declaration": "snd-alpassvv(sound, delay, feedback, maxdelay)", 
        "name": "snd-alpassvv"
    }, 
    "pl-left": {
        "description": "Produce a Dolby-encoded (stereo) signal with snd, a SOUND, encoded as the front left channel.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pl-left", 
            "snd"
        ], 
        "declaration": "pl-left(snd)", 
        "name": "pl-left"
    }, 
    "snd-bowed": {
        "description": "A bowed string instrument implemented in STK. The freq is a FLONUM in Hertz, bowpress-env is a SOUND that ranges from z ero to one, and sr is the desired sample rate (a FLONUM). You should use bowed instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-bowed", 
            "freq", 
            "bowpress-env", 
            "sr"
        ], 
        "declaration": "snd-bowed(freq,bowpress-env, sr)", 
        "name": "snd-bowed"
    }, 
    "snd-follow": {
        "description": "An envelope follower. The basic goal of this function is to generate a smooth signal that rides on the peaks of the input signal. The usual objective is to produce an amplitude envelope given a low-sample rate (control rate) signal representing local RMS measurements. The first argument is the input signal. The floor is the minimum output value. The risetime is the time (in seconds) it takes for the output to rise (exponentially) from floor to unity (1.0) and the falltime is the time it takes for the output to fall (exponentially) from unity to floor. The algorithm looks ahead for peaks and will begin to increase the output signal according to risetime in anticipation of a peak. The amount of anticipation (in sampless) is given by lookahead. The algorithm is as follows: the output value is allowed to increase according to risetime or decrease according to falltime. If the next input sample is in this range, that sample is simply output as the next output sample. If the next input sample is too large, the algorithm goes back in time as far as necessary to compute an envelope that rises according to risetime to meet the new value. The algorithm will only work backward as far as lookahead. If that is not far enough, then there is a final forward pass computing a rising signal from the earliest output sample. In this case, the output signal will be at least momentarily less than the input signal and will continue to rise exponentially until it intersects the input signal. If the input signal falls faster than indicated by falltime, the output fall rate will be limited by falltime, and the fall in output will stop when the output reaches floor. This algorithm can make two passes througth the buffer on sharply rising inputs, so it is not particularly fast. With short buffers and low sample rates this should not matter. See snd-avg above for a function that can help to generate a low-sample-rate input for snd-follow. See snd-chase in Section \"Filters\" for a related filter.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-follow", 
            "sound", 
            "floor", 
            "risetime", 
            "falltime", 
            "lookahead"
        ], 
        "declaration": "snd-follow(sound, floor, risetime, falltime, lookahead)", 
        "name": "snd-follow"
    }, 
    "get-sustain": {
        "description": "Gets the current value of the *sustain* environment variable. If *sustain* is a signal, it is evaluated at local time 0 and a number (FLONUM) is returned.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "get-sustain"
        ], 
        "declaration": "get-sustain()", 
        "name": "get-sustain"
    }, 
    "cxxxr": {
        "description": "", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "cxxxr", 
            "expr"
        ], 
        "declaration": "cxxxr(expr)", 
        "name": "cxxxr"
    }, 
    "eq-lowshelf": {
        "description": "A fixed-parameter, second-order bass shelving equalization (EQ) filter based on snd-biquad. The hz parameter (a FLONUM)is the halfway point in the transition, and gain (a FLONUM) is the bass boost (or cut) in dB. The optional slope (a FLONUM) is 1.0 by default, and response becomes peaky at values greater than 1.0.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "eq-lowshelf", 
            "signal", 
            "hz", 
            "gain", 
            "[", 
            "slope", 
            "]"
        ], 
        "declaration": "eq-lowshelf(signal, hz, gain [, slope])", 
        "name": "eq-lowshelf"
    }, 
    "delete": {
        "description": "expr - the element to delete, list - the list, :test - the test function (defaults to eql), :test-not - the test function (sense inverted) , returns - the list with the matching expressions deleted", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "delete", 
            "expr", 
            "test:", 
            "test", 
            "test-not:", 
            "test-not"
        ], 
        "declaration": "delete(expr, test: test, test-not: test-not)", 
        "name": "delete"
    }, 
    "speed-dial": {
        "description": "Generates a sequence of DTMF tones using the keys in thelist (a LIST of keys as described above under dtmf-tone). The duration of each tone is 0.2 seconds, and the space between tones is 0.1 second. Use stretch to change the \"dialing\" speed.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "speed-dial", 
            "thelist"
        ], 
        "declaration": "speed-dial(thelist)", 
        "name": "speed-dial"
    }, 
    "snd-sqrt": {
        "description": "Computes a new sound where each sample is the square root of the corresponding sample in sound. If a sample is negative, it is taken to be zero to avoid raising a floating point error. You should probably use s-sqrt instead. (See Section \"More Behaviors\".)", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-sqrt", 
            "sound"
        ], 
        "declaration": "snd-sqrt(sound)", 
        "name": "snd-sqrt"
    }, 
    "describe": {
        "description": "If description, a text string, is present, associate description with the variable named by the symbol. If symbol is not already in the workspace, it is added. If description is omitted, the function returns the current description (from a previous call) for symbol.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "describe", 
            "symbol", 
            "[", 
            "description", 
            "]"
        ], 
        "declaration": "describe(symbol [, description])", 
        "name": "describe"
    }, 
    "char": {
        "description": "chr1 - the first character to compare, chr2 - the second character(s) to compare, returns - t if predicate is true, nil otherwise, Note: case is significant with these comparison functions.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "char", 
            "chr1", 
            "chr2..."
        ], 
        "declaration": "char(chr1, chr2...)", 
        "name": "char"
    }, 
    "read-char": {
        "description": "stream - the input stream (default is standard input), returns - the character", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "read-char", 
            "[", 
            "stream", 
            "]"
        ], 
        "declaration": "read-char([stream])", 
        "name": "read-char"
    }, 
    "at": {
        "description": "Evaluate beh with *warp* shifted by time. In SAL, you can use the infix operator @ as in beh @ time. To discover how the environment is shifting time, use local-to-global(time). Most commonly, you call local-to-global(0) to find when a sound created in the current environment will start, expressed in absolute (global) terms. This can be regarded as the \"current time.\"", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "at", 
            "time", 
            "beh"
        ], 
        "declaration": "at(time, beh)", 
        "name": "at"
    }, 
    "snd-convolve": {
        "description": "Convolves sound by response using a simple O(N x M) algorithm. The sound can be any length, but the response is computed and stored in a table. The required compuation time per sample and total space are proportional to the length of response. Use convolve instead (see Section \"Filter Behaviors\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-convolve", 
            "sound", 
            "response"
        ], 
        "declaration": "snd-convolve(sound, response)", 
        "name": "snd-convolve"
    }, 
    "expr-set-attr": {
        "description": "Construct a new expression identical to expr except that the attribute has value.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "expr-set-attr", 
            "expr", 
            "attribute", 
            "value"
        ], 
        "declaration": "expr-set-attr(expr, attribute, value)", 
        "name": "expr-set-attr"
    }, 
    "pitshift": {
        "description": "A pitch shifter implemented in STK. The input sound, a single-channel or multi-channel SOUND is pitch-shifted by shift, a FLONUM ratio. A value of 1.0 means no shift. The parameter mix sets the mixture of input and shifted sounds. A value of 0.0 means input only (dry) and a value of 1.0 means shifted sound only (wet).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pitshift", 
            "sound", 
            "shift", 
            "mix"
        ], 
        "declaration": "pitshift(sound, shift, mix)", 
        "name": "pitshift"
    }, 
    "tone": {
        "description": "No longer defined; use lp instead, or define it by adding (setfn tone lp) to your program.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "tone", 
            "sound", 
            "cutoff"
        ], 
        "declaration": "tone(sound, cutoff)", 
        "name": "tone"
    }, 
    "quote": {
        "description": "expr - the expression to be quoted (quoted), returns - expr unevaluated", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "quote", 
            "expr"
        ], 
        "declaration": "quote(expr)", 
        "name": "quote"
    }, 
    "snd-modalbar": {
        "description": "Struck bar instrument model implemented in STK. The parameter t0 is the starting time (in seconds), freq is a FLONUM in Hz, preset is a FIXNUM ranging from 0 to 8, dur is a FLONUM that sets the duration (in seconds) and sr is the desired sample rate. You should use modalbar instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-modalbar", 
            "t0", 
            "freq", 
            "preset", 
            "dur", 
            "sr"
        ], 
        "declaration": "snd-modalbar(t0, freq, preset, dur, sr)", 
        "name": "snd-modalbar"
    }, 
    "eq": {
        "description": "expr1 - the first expression, expr2 - the second expression, returns - t if they are equal, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "eq", 
            "expr1", 
            "expr2"
        ], 
        "declaration": "eq(expr1, expr2)", 
        "name": "eq"
    }, 
    "when": {
        "description": "texpr - the test expression, expr - the expression(s) to be evaluated if texpr is non-nil, returns - the value of the last expression or nil", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "when", 
            "texpr", 
            "expr..."
        ], 
        "declaration": "when(texpr, expr...)", 
        "name": "when"
    }, 
    "apply-banded-bass-boost": {
        "description": "Applies a boost to low frequencies. Separates input SOUND s into FIXNUM num-bands bands from a low frequency of lowp to a high frequency of highp (these are FLONUMS that specify steps, not Hz), and scales the lowest num-boost (a FIXNUM) bands by gain, a FLONUM. The bands are summed to form the result, a SOUND.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "apply-banded-bass-boost", 
            "s", 
            "lowp", 
            "highp", 
            "num-bands", 
            "num-boost", 
            "gain"
        ], 
        "declaration": "apply-banded-bass-boost(s, lowp, highp, num-bands, num-boost, gain)", 
        "name": "apply-banded-bass-boost"
    }, 
    "snd-clarinet": {
        "description": "A clarinet model implemented in STK. The freq is a FLONUM in Hertz, breath-env is a SOUND that ranges from zero to one, and sr is the desired sample rate (a FLONUM). You should use clarinet instead (see Section \"Physical Models\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-clarinet", 
            "freq", 
            "breath-env", 
            "sr"
        ], 
        "declaration": "snd-clarinet(freq, breath-env, sr)", 
        "name": "snd-clarinet"
    }, 
    "event-time": {
        "description": "Retrieve the time field from an event.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-time", 
            "event"
        ], 
        "declaration": "event-time(event)", 
        "name": "event-time"
    }, 
    "truncate": {
        "description": "expr - the number, returns - the result of truncating the number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "truncate", 
            "expr"
        ], 
        "declaration": "truncate(expr)", 
        "name": "truncate"
    }, 
    "errset": {
        "description": "expr - the expression to execute, pflag - flag to control printing of the error message, returns - the value of the last expression consed with nil, or nil on error", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "errset", 
            "expr", 
            "[", 
            "pflag", 
            "]"
        ], 
        "declaration": "(errset expr [pflag])", 
        "name": "errset"
    }, 
    "flange": {
        "description": "A flange effect applied to snd. To vary the rate and other parameters, see the source code.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "flange", 
            "snd"
        ], 
        "declaration": "flange(snd)", 
        "name": "flange"
    }, 
    "make-sum": {
        "description": "Form sums of items (which must be numbers) from pattern x and pattern or number y. The default period lengths match the period lengths from x.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "make-sum", 
            "x", 
            "y", 
            "for:", 
            "for", 
            "name:", 
            "name", 
            "trace:", 
            "trace"
        ], 
        "declaration": "make-sum(x, y, for: for, name: name, trace: trace)", 
        "name": "make-sum"
    }, 
    "*default-control-srate*": {
        "description": "Default value for *control-srate*. This value is restored when you execute (top) to pop out of a debugging session. Change it by calling (set-control-srate value).", 
        "sal": false, 
        "is_function": false, 
        "tokens": [
            "*default-control-srate*"
        ], 
        "declaration": "*default-control-srate*", 
        "name": "*default-control-srate*"
    }, 
    "scale": {
        "description": "Scales the amplitude of sound by the factor scale. Identical function to snd-scale, except that it handles multichannel sounds. Sample rates, start times, etc. are taken from sound.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "scale", 
            "scale", 
            "sound"
        ], 
        "declaration": "scale(scale, sound)", 
        "name": "scale"
    }, 
    "peak": {
        "description": "Compute the maximum absolute value of the amplitude of a sound. The sound is created by evaluating expression (as in s-save). Only the first maxlen samples are evaluated. The expression is automatically quoted (peak is a macro), so do not quote this parameter. If expression is a variable, then the global binding of that variable will be used. Also, since the variable retains a reference to the sound, the sound will be evaluated and left in memory. See Section \"Memory Space and Normalization\" on \"Memory Space and Normalization\" for examples.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "peak", 
            "expression", 
            "maxlen"
        ], 
        "declaration": "peak(expression, maxlen)", 
        "name": "peak"
    }, 
    "eval": {
        "description": "expr - the expression to be evaluated, returns - the result of evaluating the expression", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "eval", 
            "expr"
        ], 
        "declaration": "eval(expr)", 
        "name": "eval"
    }, 
    "n1": {
        "description": "n1 - the first number to compare, n2 - the second number to compare, returns - t if the results of comparing n1 with n2, n2 with n3, etc., are all true.", 
        "sal": false, 
        "is_function": true, 
        "tokens": [
            "n1", 
            "n2..."
        ], 
        "declaration": "( n1 n2...)", 
        "name": "n1"
    }, 
    "bandpass2": {
        "description": "A fixed-parameter, second-order bandpass filter based on snd-biquad. The center frequency is given by hz (a FLONUM) and an optional Q factor is given by q (a FLONUM).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "bandpass2", 
            "signal", 
            "hz", 
            "[", 
            "q", 
            "]"
        ], 
        "declaration": "bandpass2(signal, hz [, q])", 
        "name": "bandpass2"
    }, 
    "autonorm-off": {
        "description": "Disable automatic adjustment of a scale factor applied to sounds computed using the play command.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "autonorm-off"
        ], 
        "declaration": "autonorm-off()", 
        "name": "autonorm-off"
    }, 
    "snd-buzz": {
        "description": "A buzz oscillator, which generates n harmonics of equal amplitude. The fm specifies frequency deviation (in Hertz) from hz. You should use buzz instead (see Section \"Oscillators\").", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-buzz", 
            "n", 
            "sr", 
            "hz", 
            "t0", 
            "fm"
        ], 
        "declaration": "snd-buzz(n, sr, hz, t0, fm)", 
        "name": "snd-buzz"
    }, 
    "max": {
        "description": "expr - the expressions to be checked, returns - the largest number in the list", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "max", 
            "expr..."
        ], 
        "declaration": "max(expr...)", 
        "name": "max"
    }, 
    "biquad": {
        "description": "A fixed-parameter biquad filter. All filter coefficients are FLONUMs. See also lowpass2, highpass2, bandpass2, notch2, allpass2, eq-lowshelf, eq-highshelf, eq-band, lowpass4, lowpass6, highpass4, and highpass8 in this section for convenient variations based on the same filter. The equations for the filter are: zn = sn + a1 * zn-1 + a2 * zn-2, and yn = zn * b0 + zn-1 * b1 + zn-2 * b2.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "biquad", 
            "signal", 
            "b0", 
            "b1", 
            "b2", 
            "a0", 
            "a1", 
            "a2"
        ], 
        "declaration": "biquad(signal, b0, b1, b2, a0, a1, a2)", 
        "name": "biquad"
    }, 
    "pwlv-list": {
        "description": "A version of pwlv that takes a single list of breakpoints as its argument. See pwl-list above for the rationale.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "pwlv-list", 
            "breakpoints"
        ], 
        "declaration": "pwlv-list(breakpoints)", 
        "name": "pwlv-list"
    }, 
    "oddp": {
        "description": "expr - the integer to test, returns - t if the integer is odd, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "oddp", 
            "expr"
        ], 
        "declaration": "oddp(expr)", 
        "name": "oddp"
    }, 
    "agc": {
        "description": "An automatic gain control applied to input. The maximum gain in dB is range. Peaks are attenuated to 1.0, and gain is controlled with the given rise-time and fall-time. The look-ahead time default is rise-time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "agc", 
            "input", 
            "range", 
            "rise-time", 
            "fall-time", 
            "[", 
            "lookahead", 
            "]"
        ], 
        "declaration": "agc(input,range, rise-time, fall-time [, lookahead])", 
        "name": "agc"
    }, 
    "event-set-time": {
        "description": "Construct a new event where the time of event is replaced by time.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-set-time", 
            "event", 
            "time"
        ], 
        "declaration": "event-set-time(event, time)", 
        "name": "event-set-time"
    }, 
    "delete-if-not": {
        "description": "test - the test predicate, list - the list, returns - the list with non-matching elements deleted", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "delete-if-not", 
            "test", 
            "list"
        ], 
        "declaration": "delete-if-not(test, list)", 
        "name": "delete-if-not"
    }, 
    "push": {
        "description": "Push val onto lis (a Lisp list). This is a macro that is equivalent to writing (in Lisp) (setf lis (cons val lis)).", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "push", 
            "val", 
            "lis"
        ], 
        "declaration": "push(val, lis)", 
        "name": "push"
    }, 
    "sin": {
        "description": "expr - the floating point number, returns - the sine of the number", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "sin", 
            "expr"
        ], 
        "declaration": "sin(expr)", 
        "name": "sin"
    }, 
    "event-set-expression": {
        "description": "Construct a new event where the expression of event is replaced by expression.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "event-set-expression", 
            "event", 
            "dur"
        ], 
        "declaration": "event-set-expression(event, dur)", 
        "name": "event-set-expression"
    }, 
    "snd-set-latency": {
        "description": "Set the latency requested when Nyquist plays sound to latency, a FLONUM. The previous value is returned. The default is 0.3 seconds. To avoid glitches, the latency should be greater than the time required for garbage collection and message printing and any other system activity external to Nyquist.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "snd-set-latency", 
            "latency"
        ], 
        "declaration": "snd-set-latency(latency)", 
        "name": "snd-set-latency"
    }, 
    "add-to-workspace": {
        "description": "Adds a global variable to the workspace. The symbol should be a (quoted) symbol.", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "add-to-workspace", 
            "symbol"
        ], 
        "declaration": "add-to-workspace(symbol)", 
        "name": "add-to-workspace"
    }, 
    "stringp": {
        "description": "expr - the expression to check, returns - t if the value is a string, nil otherwise", 
        "sal": true, 
        "is_function": true, 
        "tokens": [
            "stringp", 
            "expr"
        ], 
        "declaration": "stringp(expr)", 
        "name": "stringp"
    }
}